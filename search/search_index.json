{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cogeo-mosaic \u00b6 Create mosaics of Cloud Optimized GeoTIFF based on mosaicJSON specification. Documentation : developmentseed.org/cogeo-mosaic/ Source Code : developmentseed/cogeo-mosaic Read the official announcement medium.com/devseed/cog-talk-part-2-mosaics-bbbf474e66df Install (python >=3) \u00b6 $ pip install pip -U $ pip install cogeo-mosaic # Or from source $ pip install git+http://github.com/developmentseed/cogeo-mosaic Notes : Starting with version 2.0, pygeos has replaced shapely and thus makes libgeos a requirement. pygeos hosted on pypi migth not compile on certain machine. This has been fixed in the master branch and can be installed with pip install git+https://github.com/pygeos/pygeos.git See it in actions \u00b6 TiTiler : A lightweight Cloud Optimized GeoTIFF dynamic tile server (COG, STAC and MosaicJSON). Contribution & Development \u00b6 See CONTRIBUTING.md License \u00b6 See LICENSE Authors \u00b6 Created by Development Seed Changes \u00b6 See CHANGES.md .","title":"Home"},{"location":"#cogeo-mosaic","text":"Create mosaics of Cloud Optimized GeoTIFF based on mosaicJSON specification. Documentation : developmentseed.org/cogeo-mosaic/ Source Code : developmentseed/cogeo-mosaic Read the official announcement medium.com/devseed/cog-talk-part-2-mosaics-bbbf474e66df","title":"cogeo-mosaic"},{"location":"#install-python-3","text":"$ pip install pip -U $ pip install cogeo-mosaic # Or from source $ pip install git+http://github.com/developmentseed/cogeo-mosaic Notes : Starting with version 2.0, pygeos has replaced shapely and thus makes libgeos a requirement. pygeos hosted on pypi migth not compile on certain machine. This has been fixed in the master branch and can be installed with pip install git+https://github.com/pygeos/pygeos.git","title":"Install (python &gt;=3)"},{"location":"#see-it-in-actions","text":"TiTiler : A lightweight Cloud Optimized GeoTIFF dynamic tile server (COG, STAC and MosaicJSON).","title":"See it in actions"},{"location":"#contribution-development","text":"See CONTRIBUTING.md","title":"Contribution &amp; Development"},{"location":"#license","text":"See LICENSE","title":"License"},{"location":"#authors","text":"Created by Development Seed","title":"Authors"},{"location":"#changes","text":"See CHANGES.md .","title":"Changes"},{"location":"cli/","text":"CLI \u00b6 $ cogeo-mosaic --help Usage: cogeo-mosaic [OPTIONS] COMMAND [ARGS]... cogeo_mosaic cli. Options: --version Show the version and exit. --help Show this message and exit. Commands: create Create mosaic definition from list of files create-from-features Create mosaic definition from GeoJSON features or features collection footprint Create geojson from list of files info Return info about the mosaic overview [EXPERIMENTAL] Create a low resolution mosaic image from a MosaicJSON. to-geojson Create GeoJSON from a MosaicJSON document update Update a mosaic definition from list of files upload Upload mosaic definition to backend Create \u00b6 $ cogeo-mosaic create --help Usage: cogeo-mosaic create [ OPTIONS ] [ INPUT_FILES ] Create mosaic definition file. Options: -o, --output PATH Output file name --minzoom INTEGER An integer to overwrite the minimum zoom level derived from the COGs. --maxzoom INTEGER An integer to overwrite the maximum zoom level derived from the COGs. --quadkey-zoom INTEGER An integer to overwrite the quadkey zoom level used for keys in the MosaicJSON. --min-tile-cover FLOAT Minimum % overlap --tile-cover-sort Sort files by covering % --threads INTEGER threads -q, --quiet Remove progressbar and other non-error output. --help Show this message and exit. [INPUT_FILES] must be a list of valid Cloud Optimized GeoTIFF. $ cogeo-mosaic create list.txt -o mosaic.json # or $ cat list.txt | cogeo-mosaic create - | gzip > mosaic.json.gz # or use backends like AWS S3 or DynamoDB $ cogeo-mosaic create list.txt -o s3://my-bucket/my-key.json.gz Example: create a mosaic from OAM \u00b6 # Create Mosaic $ curl https://api.openaerialmap.org/user/5d6a0d1a2103c90007707fa0 | jq -r '.results.images[] | .uuid' | cogeo-mosaic create - | gzip > 5d6a0d1a2103c90007707fa0.json.gz # Create Footprint (optional) $ curl https://api.openaerialmap.org/user/5d6a0d1a2103c90007707fa0 | jq -r '.results.images[] | .uuid' | cogeo-mosaic footprint | gist -p -f test.geojson Create Mosaic definition from a GeoJSON features collection (e.g STAC) \u00b6 This module is first design to create mosaicJSON from a set of COG urls but starting in version 3.0.0 we have added a CLI to be able to create mosaicJSON from GeoJSON features. $ cogeo-mosaic create-from-features --help Usage: cogeo-mosaic create-from-features [OPTIONS] FEATURES... Create mosaic definition file. Options: -o, --output PATH Output file name --minzoom INTEGER Mosaic minimum zoom level. [required] --maxzoom INTEGER Mosaic maximum zoom level. [required] --property TEXT Define accessor property [required] --quadkey-zoom INTEGER An integer to overwrite the quadkey zoom level used for keys in the MosaicJSON. --min-tile-cover FLOAT Minimum % overlap --tile-cover-sort Sort files by covering % -q, --quiet Remove progressbar and other non-error output. --help Show this message and exit. Use it with STAC \u00b6 $ curl https://earth-search.aws.element84.com/collections/landsat-8-l1/items | \\ cogeo-mosaic create-from-features --minzoom 7 --maxzoom 12 --property \"landsat:scene_id\" --quiet | \\ jq { \"mosaicjson\" : \"0.0.2\" , \"version\" : \"1.0.0\" , \"minzoom\" : 7 , \"maxzoom\" : 12 , \"quadkey_zoom\" : 7 , \"bounds\" : [ 16 .142300225571994, -28.513088675819393, 67 .21380296165974, 81 .2067478836583 ] , \"center\" : [ 41 .67805159361586, 26 .346829603919453, 7 ] , \"tiles\" : { \"1012123\" : [ \"LC81930022020114LGN00\" ] , ... } } Create Mosaic Overview [experimental] \u00b6 The CLI provides an overview command to create low-resolution version of a mosaic. This is hightly experimental and might incure some cost if you are hosting mosaic on DynamoDB or COG files on S3. To create the overview, the overview method will fetch all the asset's overviews (COG internal overview) and construct one or multiple COG . $ cogeo-mosaic overview s3://bucket/mymosaic.json","title":"CLI"},{"location":"cli/#cli","text":"$ cogeo-mosaic --help Usage: cogeo-mosaic [OPTIONS] COMMAND [ARGS]... cogeo_mosaic cli. Options: --version Show the version and exit. --help Show this message and exit. Commands: create Create mosaic definition from list of files create-from-features Create mosaic definition from GeoJSON features or features collection footprint Create geojson from list of files info Return info about the mosaic overview [EXPERIMENTAL] Create a low resolution mosaic image from a MosaicJSON. to-geojson Create GeoJSON from a MosaicJSON document update Update a mosaic definition from list of files upload Upload mosaic definition to backend","title":"CLI"},{"location":"cli/#create","text":"$ cogeo-mosaic create --help Usage: cogeo-mosaic create [ OPTIONS ] [ INPUT_FILES ] Create mosaic definition file. Options: -o, --output PATH Output file name --minzoom INTEGER An integer to overwrite the minimum zoom level derived from the COGs. --maxzoom INTEGER An integer to overwrite the maximum zoom level derived from the COGs. --quadkey-zoom INTEGER An integer to overwrite the quadkey zoom level used for keys in the MosaicJSON. --min-tile-cover FLOAT Minimum % overlap --tile-cover-sort Sort files by covering % --threads INTEGER threads -q, --quiet Remove progressbar and other non-error output. --help Show this message and exit. [INPUT_FILES] must be a list of valid Cloud Optimized GeoTIFF. $ cogeo-mosaic create list.txt -o mosaic.json # or $ cat list.txt | cogeo-mosaic create - | gzip > mosaic.json.gz # or use backends like AWS S3 or DynamoDB $ cogeo-mosaic create list.txt -o s3://my-bucket/my-key.json.gz","title":"Create"},{"location":"cli/#example-create-a-mosaic-from-oam","text":"# Create Mosaic $ curl https://api.openaerialmap.org/user/5d6a0d1a2103c90007707fa0 | jq -r '.results.images[] | .uuid' | cogeo-mosaic create - | gzip > 5d6a0d1a2103c90007707fa0.json.gz # Create Footprint (optional) $ curl https://api.openaerialmap.org/user/5d6a0d1a2103c90007707fa0 | jq -r '.results.images[] | .uuid' | cogeo-mosaic footprint | gist -p -f test.geojson","title":"Example: create a mosaic from OAM"},{"location":"cli/#create-mosaic-definition-from-a-geojson-features-collection-eg-stac","text":"This module is first design to create mosaicJSON from a set of COG urls but starting in version 3.0.0 we have added a CLI to be able to create mosaicJSON from GeoJSON features. $ cogeo-mosaic create-from-features --help Usage: cogeo-mosaic create-from-features [OPTIONS] FEATURES... Create mosaic definition file. Options: -o, --output PATH Output file name --minzoom INTEGER Mosaic minimum zoom level. [required] --maxzoom INTEGER Mosaic maximum zoom level. [required] --property TEXT Define accessor property [required] --quadkey-zoom INTEGER An integer to overwrite the quadkey zoom level used for keys in the MosaicJSON. --min-tile-cover FLOAT Minimum % overlap --tile-cover-sort Sort files by covering % -q, --quiet Remove progressbar and other non-error output. --help Show this message and exit.","title":"Create Mosaic definition from a GeoJSON features collection (e.g STAC)"},{"location":"cli/#use-it-with-stac","text":"$ curl https://earth-search.aws.element84.com/collections/landsat-8-l1/items | \\ cogeo-mosaic create-from-features --minzoom 7 --maxzoom 12 --property \"landsat:scene_id\" --quiet | \\ jq { \"mosaicjson\" : \"0.0.2\" , \"version\" : \"1.0.0\" , \"minzoom\" : 7 , \"maxzoom\" : 12 , \"quadkey_zoom\" : 7 , \"bounds\" : [ 16 .142300225571994, -28.513088675819393, 67 .21380296165974, 81 .2067478836583 ] , \"center\" : [ 41 .67805159361586, 26 .346829603919453, 7 ] , \"tiles\" : { \"1012123\" : [ \"LC81930022020114LGN00\" ] , ... } }","title":"Use it with STAC"},{"location":"cli/#create-mosaic-overview-experimental","text":"The CLI provides an overview command to create low-resolution version of a mosaic. This is hightly experimental and might incure some cost if you are hosting mosaic on DynamoDB or COG files on S3. To create the overview, the overview method will fetch all the asset's overviews (COG internal overview) and construct one or multiple COG . $ cogeo-mosaic overview s3://bucket/mymosaic.json","title":"Create Mosaic Overview [experimental]"},{"location":"contributing/","text":"Development - Contributing \u00b6 Issues and pull requests are more than welcome. Dev install & Pull-Request $ git clone http://github.com/developmentseed/cogeo-mosaic.git $ cd cogeo-mosaic $ pip install -e .[dev] Python >=3.7 only This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install $ git add . $ git commit -m'my change' isort....................................................................Passed black....................................................................Passed Flake8...................................................................Passed Verifying PEP257 Compliance..............................................Passed mypy.....................................................................Passed $ git push origin Docs \u00b6 $ git clone https://github.com/developmentseed/cogeo-mosaic.git $ cd titiler $ pip install -e . [ \"docs\" ] Hot-reloading docs: $ mkdocs serve To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.): $ mkdocs gh-deploy","title":"Development - Contributing"},{"location":"contributing/#development-contributing","text":"Issues and pull requests are more than welcome. Dev install & Pull-Request $ git clone http://github.com/developmentseed/cogeo-mosaic.git $ cd cogeo-mosaic $ pip install -e .[dev] Python >=3.7 only This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install $ git add . $ git commit -m'my change' isort....................................................................Passed black....................................................................Passed Flake8...................................................................Passed Verifying PEP257 Compliance..............................................Passed mypy.....................................................................Passed $ git push origin","title":"Development - Contributing"},{"location":"contributing/#docs","text":"$ git clone https://github.com/developmentseed/cogeo-mosaic.git $ cd titiler $ pip install -e . [ \"docs\" ] Hot-reloading docs: $ mkdocs serve To manually deploy docs (note you should never need to do this because Github Actions deploys automatically for new commits.): $ mkdocs gh-deploy","title":"Docs"},{"location":"intro/","text":"cogeo-mosaic is set of CLI and API to create, store and read MosaicJSON documents. MosaicJSON Model \u00b6 cogeo-mosaic uses Pydantic model to store and validate mosaicJSON documents. class MosaicJSON ( BaseModel ): mosaicjson : str name : Optional [ str ] description : Optional [ str ] version : str = \"1.0.0\" attribution : Optional [ str ] minzoom : int = Field ( 0 , ge = 0 , le = 30 ) maxzoom : int = Field ( 30 , ge = 0 , le = 30 ) quadkey_zoom : Optional [ int ] bounds : List [ float ] = Field ([ - 180 , - 90 , 180 , 90 ]) center : Optional [ Tuple [ float , float , int ]] tiles : Dict [ str , List [ str ]] The model is based on the mosaicjson specification: developmentseed/mosaicjson-spec Pydantic models are python classes which are extansible. Here is an example of how we can use the MosaicJSON model to create a mosaic from a list of COG urls: from cogeo_mosaic.mosaic import MosaicJSON # list of COG dataset = [ \"1.tif\" , \"2.tif\" ] mosaic_definition = MosaicJSON . from_urls ( dataset ) print ( mosaic_definition . tiles ) > { \"tile\" : { \"00001\" : [ \"cog1.tif\" , \"2.tif\" ]}} Lear more on MosaicJSON class API/mosaic . Backends \u00b6 backends are python classed, based on rio-tiler BaseReader , which are used to interact with MosaicJSON documents weither they are stored on AWS dynamoBD, AWS S3, localy or on the web (http://). Because each Backends extend rio-tiler BaseReader they share the same minimal methods/properties from cogeo_mosaic.backends import MosaicBackend # Read with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : mosaic . mosaic_def # property - MosaicJSON document, wrapped in a Pydantic Model mosaic . metadata # property - Return mosaic metadata mosaic . mosaicid # property - Return sha224 id from the mosaicjson doc mosaic . quadkey_zoom # property - Return Quadkey zoom of the mosaic mosaic . minzoom # property - Mosaic minzoom mosaic . maxzoom # property - Mosaic maxzoom mosaic . bounds # property - Mosaic bounds mosaic . spatial_info # property - zooms and bounds info mosaic . info ( quadkeys = True / False ) # method - spatial_info, list of quadkeys and mosaic name mosaic . assets_for_tile ( 1 , 2 , 3 ) # method - Find assets for a specific mercator tile mosaic . assets_for_point ( lng , lat ) # method - Find assets for a specific point mosaic . tile ( 1 , 2 , 3 ) # method - Create mosaic tile mosaic . point ( lng , lat ) # method - Read point value from multiple assets mosaic . write () # method - Write the mosaicjson to the given location mosaic . update ([ features ]) # method - Update the mosaicjson data with a list of features Read and Get assets list \u00b6 # MosaicBackend is the top level backend and will distribute to the # correct backend by checking the path/url schema. from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : assets : List = mosaic . assets_for_tile ( 1 , 2 , 3 ) # get assets for mercantile.Tile(1, 2, 3) Read Tile Data (mosaic tile) \u00b6 # MosaicBackend is the top level backend and will distribute to the # correct backend by checking the path/url schema. from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : img , assets_used = mosaic . tile ( 1 , 2 , 3 ) Write \u00b6 from cogeo_mosaic.mosaic import MosaicJSON from cogeo_mosaic.backends import MosaicBackend mosaicdata = MosaicJSON . from_urls ([ \"1.tif\" , \"2.tif\" ]) with MosaicBackend ( \"s3://mybucket/amosaic.json\" , mosaic_def = mosaicdata ) as mosaic : mosaic . write () # trigger upload to S3 Update \u00b6 from cogeo_mosaic.utils import get_footprints from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : features = get_footprints ([ \"3.tif\" ]) # Get footprint mosaic . update ( features ) # Update mosaicJSON and upload to S3 In Memory \u00b6 from cogeo_mosaic.mosaic import MosaicJSON from cogeo_mosaic.backends import MosaicBackend mosaic_definition = MosaicJSON . from_urls ([ \"1.tif\" , \"2.tif\" ]) with MosaicBackend ( None , mosaic_def = mosaicdata ) as mosaic : img , assets_used = mosaic . tile ( 1 , 2 , 3 ) Image Order \u00b6 By default the order of the dataset, either passed via the CLI or in the API, defines the order of the quadkey's assets. from cogeo_mosaic.mosaic import MosaicJSON # list of COG dataset = [ \"1.tif\" , \"2.tif\" ] mosaic_definition = MosaicJSON . from_urls ( dataset ) print ( mosaic_definition . tiles ) > { \"tile\" : { \"0\" : [ \"1.tif\" , \"2.tif\" ]}}","title":"Intro"},{"location":"intro/#mosaicjson-model","text":"cogeo-mosaic uses Pydantic model to store and validate mosaicJSON documents. class MosaicJSON ( BaseModel ): mosaicjson : str name : Optional [ str ] description : Optional [ str ] version : str = \"1.0.0\" attribution : Optional [ str ] minzoom : int = Field ( 0 , ge = 0 , le = 30 ) maxzoom : int = Field ( 30 , ge = 0 , le = 30 ) quadkey_zoom : Optional [ int ] bounds : List [ float ] = Field ([ - 180 , - 90 , 180 , 90 ]) center : Optional [ Tuple [ float , float , int ]] tiles : Dict [ str , List [ str ]] The model is based on the mosaicjson specification: developmentseed/mosaicjson-spec Pydantic models are python classes which are extansible. Here is an example of how we can use the MosaicJSON model to create a mosaic from a list of COG urls: from cogeo_mosaic.mosaic import MosaicJSON # list of COG dataset = [ \"1.tif\" , \"2.tif\" ] mosaic_definition = MosaicJSON . from_urls ( dataset ) print ( mosaic_definition . tiles ) > { \"tile\" : { \"00001\" : [ \"cog1.tif\" , \"2.tif\" ]}} Lear more on MosaicJSON class API/mosaic .","title":"MosaicJSON Model"},{"location":"intro/#backends","text":"backends are python classed, based on rio-tiler BaseReader , which are used to interact with MosaicJSON documents weither they are stored on AWS dynamoBD, AWS S3, localy or on the web (http://). Because each Backends extend rio-tiler BaseReader they share the same minimal methods/properties from cogeo_mosaic.backends import MosaicBackend # Read with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : mosaic . mosaic_def # property - MosaicJSON document, wrapped in a Pydantic Model mosaic . metadata # property - Return mosaic metadata mosaic . mosaicid # property - Return sha224 id from the mosaicjson doc mosaic . quadkey_zoom # property - Return Quadkey zoom of the mosaic mosaic . minzoom # property - Mosaic minzoom mosaic . maxzoom # property - Mosaic maxzoom mosaic . bounds # property - Mosaic bounds mosaic . spatial_info # property - zooms and bounds info mosaic . info ( quadkeys = True / False ) # method - spatial_info, list of quadkeys and mosaic name mosaic . assets_for_tile ( 1 , 2 , 3 ) # method - Find assets for a specific mercator tile mosaic . assets_for_point ( lng , lat ) # method - Find assets for a specific point mosaic . tile ( 1 , 2 , 3 ) # method - Create mosaic tile mosaic . point ( lng , lat ) # method - Read point value from multiple assets mosaic . write () # method - Write the mosaicjson to the given location mosaic . update ([ features ]) # method - Update the mosaicjson data with a list of features","title":"Backends"},{"location":"intro/#read-and-get-assets-list","text":"# MosaicBackend is the top level backend and will distribute to the # correct backend by checking the path/url schema. from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : assets : List = mosaic . assets_for_tile ( 1 , 2 , 3 ) # get assets for mercantile.Tile(1, 2, 3)","title":"Read and Get assets list"},{"location":"intro/#read-tile-data-mosaic-tile","text":"# MosaicBackend is the top level backend and will distribute to the # correct backend by checking the path/url schema. from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : img , assets_used = mosaic . tile ( 1 , 2 , 3 )","title":"Read Tile Data (mosaic tile)"},{"location":"intro/#write","text":"from cogeo_mosaic.mosaic import MosaicJSON from cogeo_mosaic.backends import MosaicBackend mosaicdata = MosaicJSON . from_urls ([ \"1.tif\" , \"2.tif\" ]) with MosaicBackend ( \"s3://mybucket/amosaic.json\" , mosaic_def = mosaicdata ) as mosaic : mosaic . write () # trigger upload to S3","title":"Write"},{"location":"intro/#update","text":"from cogeo_mosaic.utils import get_footprints from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : features = get_footprints ([ \"3.tif\" ]) # Get footprint mosaic . update ( features ) # Update mosaicJSON and upload to S3","title":"Update"},{"location":"intro/#in-memory","text":"from cogeo_mosaic.mosaic import MosaicJSON from cogeo_mosaic.backends import MosaicBackend mosaic_definition = MosaicJSON . from_urls ([ \"1.tif\" , \"2.tif\" ]) with MosaicBackend ( None , mosaic_def = mosaicdata ) as mosaic : img , assets_used = mosaic . tile ( 1 , 2 , 3 )","title":"In Memory"},{"location":"intro/#image-order","text":"By default the order of the dataset, either passed via the CLI or in the API, defines the order of the quadkey's assets. from cogeo_mosaic.mosaic import MosaicJSON # list of COG dataset = [ \"1.tif\" , \"2.tif\" ] mosaic_definition = MosaicJSON . from_urls ( dataset ) print ( mosaic_definition . tiles ) > { \"tile\" : { \"0\" : [ \"1.tif\" , \"2.tif\" ]}}","title":"Image Order"},{"location":"release-notes/","text":"Release Notes \u00b6 3.0.0a18 (2020-11-24) \u00b6 ** update Backend base class for rio-tiler 2.0.0rc3 (add .feature() method) 3.0.0a17 (2020-11-09) \u00b6 update for rio-tiler 2.0rc and add backend output models 3.0.0a16 (2020-10-26) \u00b6 raise MosaicNotFoundError when mosaic doesn't exists in the DynamoDB table. 3.0.0a15 (2020-10-22) \u00b6 fix typo in DynamoDB backend ( developmentseed/cogeo-mosaic!134 ) rename cogeo_mosaic/backends/http.py -> cogeo_mosaic/backends/web.py to avoid conflicts (author @kylebarron, developmentseed/cogeo-mosaic!133 ) 3.0.0a14 (2020-10-22) \u00b6 add logger ( cogeo_mosaic.logger.logger ) Update STACBackend to better handler paggination (ref: developmentseed/cogeo-mosaic!125 ) with change from #125, stac_next_link_key has be specified if you know the STAC API is using the latest specs: with MosaicBackend ( f \"stac+ { stac_endpoint } \" , query . copy (), 11 , 14 , backend_options = { \"accessor\" : lambda feature : feature [ \"id\" ], \"stac_next_link_key\" : \"next\" , } ) as mosaic : add to-geojson CLI to create a GeoJSON from a mosaicJSON document (#128) refactor internal cache ( developmentseed/cogeo-mosaic!131 ) add progressbar for iterating over quadkeys when creating a mosaic (author @kylebarron, developmentseed/cogeo-mosaic!130 ) Breaking changes \u00b6 refactored DynamoDB backend to store multiple mosaics in one table ( developmentseed/cogeo-mosaic!127 ) new path schema dynamodb://{REGION}?/{TABLE}:{MOSAIC} renamed exception MosaicExists to MosaicExistsError renamed option fetch_quadkeys to quadkeys in DynamoDBBackend.info() method add quadkeys option in Backends.info() to return (or not) the list of quadkeys ( developmentseed/cogeo-mosaic!129 ) moves get_assets to the base Backend ( developmentseed/cogeo-mosaic!131 ) remove multi_level mosaic support ( developmentseed/cogeo-mosaic#122 ) 3.0.0a13 (2020-10-13) \u00b6 add TMS in BaseBackend to align with rio-tiler BaseBackend. 3.0.0a12 (2020-10-07) \u00b6 remove pkg_resources ( pypa/setuptools#510 ) raise error when minimum_tile_cover is > 1 ( developmentseed/cogeo-mosaic#117 ) fix wrong indices sorting in default_filter ( developmentseed/cogeo-mosaic#118 ) Note: We changed the versioning scheme to {major}.{minor}.{path}{pre}{prenum} 3.0a11 (2020-09-21) \u00b6 Raise Exception when trying to overwrite a mosaic (#112) Add reverse option in .tile and .point to get values from assets in reversed order. 3.0a10 (2020-08-24) \u00b6 Allow PointOutsideBounds exception for point method (#108) 3.0a9 (2020-08-24) \u00b6 BaseBackend.center returns value from the mosaic definition (#105) 3.0a8 (2020-08-21) \u00b6 BaseBackend is now a subclass of rio-tiler.io.base.BaseReader (add minzoom, maxzoom, bounds properties and info method) use attr to define backend classes Breaking changes \u00b6 backend_options is now used to pass options (*kwargs) to the _read method 3.0a7 (2020-07-31) \u00b6 update to rio-tiler 2.0b5 Breaking changes \u00b6 'value' -> 'values' in MosaicBackend.point output (#98) 3.0a6 (2020-07-31) \u00b6 Use environement variable to set/disable cache (#93, autho @geospatial-jeff) Allow Threads configuration for overview command (author @kylebarron) add --in-memory/--no-in-memory to control temporary files creation for overview function. allow pixel_selection method options for overview function. update to rio-tiler 2.0b4 use new COGReader and STACReader to add .tile and .point methods directly in the backends Breaking changes \u00b6 backend.tile -> backend.assets_for_tile backend.point -> backend.assets_for_point 3.0a5 (2020-06-29) \u00b6 remove FTP from supported backend (#87, author @geospatial-jeff) add backend CRUD exceptions (#86, author @geospatial-jeff) 3.0a4 (2020-06-25) \u00b6 add STACBackend (#82) fix backends caching and switch to TTL cache (#83) 3.0a3 (2020-05-01) \u00b6 add Upload CLI (#74, author @kylebarron) fix boto3 dynamodb exception (#75) 3.0a2 (2020-05-01) \u00b6 Better mosaicJSON model testing and default center from bounds (#73, author @geospatial-jeff) 3.0a1 (2020-05-01) \u00b6 This is a major version, meaning a lot of refactoring was done and may lead to breaking changes. add quadkey_zoom option in CLI (#41, author @kylebarron) use R-tree from pygeos for testing intersections (#43, author @kylebarron) Breaking changes \u00b6 added BackendStorage for dynamodb, s3, file and http (with @kylebarron) added MosaicJSON pydantic model for internal mosaicjson representation (with @kylebarron and @geospatial-jeff) 2.0.1 (2020-01-28) \u00b6 Bug fix, use pygeos from pypi instead of git repo 2.0.0 (2020-01-28) - Major refactor \u00b6 remove stack related code (lambda handler, serverless) switch to pygeos (#24) bug fixes add last pixel_method 1.0.0 (2019-12-13) \u00b6 add tif output fix overview creation add other Web templates 0.3.0 (2019-11-07) \u00b6 use aws lambda layer add update_mosaic utility function add /tiles/point endpoint to get points values from a mosaic add logs for mosaic creation add custom pixel methods add custom color maps Breaking changes \u00b6 rename /mosaic/info/<mosaicid> to /mosaic/<mosaicid>/info 0.2.0 (2019-09-30) \u00b6 update for lambda-proxy~=5.0 (#15) add minimum_tile_cover option for mosaic creation (#16) add tile_cover_sort option (#16) add verbosity for cli 0.1.0 (2019-09-05) \u00b6 add /create.html endpoint (#14) update to remotepixel/amazonlinux docker image","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#300a18-2020-11-24","text":"** update Backend base class for rio-tiler 2.0.0rc3 (add .feature() method)","title":"3.0.0a18 (2020-11-24)"},{"location":"release-notes/#300a17-2020-11-09","text":"update for rio-tiler 2.0rc and add backend output models","title":"3.0.0a17 (2020-11-09)"},{"location":"release-notes/#300a16-2020-10-26","text":"raise MosaicNotFoundError when mosaic doesn't exists in the DynamoDB table.","title":"3.0.0a16 (2020-10-26)"},{"location":"release-notes/#300a15-2020-10-22","text":"fix typo in DynamoDB backend ( developmentseed/cogeo-mosaic!134 ) rename cogeo_mosaic/backends/http.py -> cogeo_mosaic/backends/web.py to avoid conflicts (author @kylebarron, developmentseed/cogeo-mosaic!133 )","title":"3.0.0a15 (2020-10-22)"},{"location":"release-notes/#300a14-2020-10-22","text":"add logger ( cogeo_mosaic.logger.logger ) Update STACBackend to better handler paggination (ref: developmentseed/cogeo-mosaic!125 ) with change from #125, stac_next_link_key has be specified if you know the STAC API is using the latest specs: with MosaicBackend ( f \"stac+ { stac_endpoint } \" , query . copy (), 11 , 14 , backend_options = { \"accessor\" : lambda feature : feature [ \"id\" ], \"stac_next_link_key\" : \"next\" , } ) as mosaic : add to-geojson CLI to create a GeoJSON from a mosaicJSON document (#128) refactor internal cache ( developmentseed/cogeo-mosaic!131 ) add progressbar for iterating over quadkeys when creating a mosaic (author @kylebarron, developmentseed/cogeo-mosaic!130 )","title":"3.0.0a14 (2020-10-22)"},{"location":"release-notes/#breaking-changes","text":"refactored DynamoDB backend to store multiple mosaics in one table ( developmentseed/cogeo-mosaic!127 ) new path schema dynamodb://{REGION}?/{TABLE}:{MOSAIC} renamed exception MosaicExists to MosaicExistsError renamed option fetch_quadkeys to quadkeys in DynamoDBBackend.info() method add quadkeys option in Backends.info() to return (or not) the list of quadkeys ( developmentseed/cogeo-mosaic!129 ) moves get_assets to the base Backend ( developmentseed/cogeo-mosaic!131 ) remove multi_level mosaic support ( developmentseed/cogeo-mosaic#122 )","title":"Breaking changes"},{"location":"release-notes/#300a13-2020-10-13","text":"add TMS in BaseBackend to align with rio-tiler BaseBackend.","title":"3.0.0a13 (2020-10-13)"},{"location":"release-notes/#300a12-2020-10-07","text":"remove pkg_resources ( pypa/setuptools#510 ) raise error when minimum_tile_cover is > 1 ( developmentseed/cogeo-mosaic#117 ) fix wrong indices sorting in default_filter ( developmentseed/cogeo-mosaic#118 ) Note: We changed the versioning scheme to {major}.{minor}.{path}{pre}{prenum}","title":"3.0.0a12 (2020-10-07)"},{"location":"release-notes/#30a11-2020-09-21","text":"Raise Exception when trying to overwrite a mosaic (#112) Add reverse option in .tile and .point to get values from assets in reversed order.","title":"3.0a11 (2020-09-21)"},{"location":"release-notes/#30a10-2020-08-24","text":"Allow PointOutsideBounds exception for point method (#108)","title":"3.0a10 (2020-08-24)"},{"location":"release-notes/#30a9-2020-08-24","text":"BaseBackend.center returns value from the mosaic definition (#105)","title":"3.0a9 (2020-08-24)"},{"location":"release-notes/#30a8-2020-08-21","text":"BaseBackend is now a subclass of rio-tiler.io.base.BaseReader (add minzoom, maxzoom, bounds properties and info method) use attr to define backend classes","title":"3.0a8 (2020-08-21)"},{"location":"release-notes/#breaking-changes_1","text":"backend_options is now used to pass options (*kwargs) to the _read method","title":"Breaking changes"},{"location":"release-notes/#30a7-2020-07-31","text":"update to rio-tiler 2.0b5","title":"3.0a7 (2020-07-31)"},{"location":"release-notes/#breaking-changes_2","text":"'value' -> 'values' in MosaicBackend.point output (#98)","title":"Breaking changes"},{"location":"release-notes/#30a6-2020-07-31","text":"Use environement variable to set/disable cache (#93, autho @geospatial-jeff) Allow Threads configuration for overview command (author @kylebarron) add --in-memory/--no-in-memory to control temporary files creation for overview function. allow pixel_selection method options for overview function. update to rio-tiler 2.0b4 use new COGReader and STACReader to add .tile and .point methods directly in the backends","title":"3.0a6 (2020-07-31)"},{"location":"release-notes/#breaking-changes_3","text":"backend.tile -> backend.assets_for_tile backend.point -> backend.assets_for_point","title":"Breaking changes"},{"location":"release-notes/#30a5-2020-06-29","text":"remove FTP from supported backend (#87, author @geospatial-jeff) add backend CRUD exceptions (#86, author @geospatial-jeff)","title":"3.0a5 (2020-06-29)"},{"location":"release-notes/#30a4-2020-06-25","text":"add STACBackend (#82) fix backends caching and switch to TTL cache (#83)","title":"3.0a4 (2020-06-25)"},{"location":"release-notes/#30a3-2020-05-01","text":"add Upload CLI (#74, author @kylebarron) fix boto3 dynamodb exception (#75)","title":"3.0a3 (2020-05-01)"},{"location":"release-notes/#30a2-2020-05-01","text":"Better mosaicJSON model testing and default center from bounds (#73, author @geospatial-jeff)","title":"3.0a2 (2020-05-01)"},{"location":"release-notes/#30a1-2020-05-01","text":"This is a major version, meaning a lot of refactoring was done and may lead to breaking changes. add quadkey_zoom option in CLI (#41, author @kylebarron) use R-tree from pygeos for testing intersections (#43, author @kylebarron)","title":"3.0a1 (2020-05-01)"},{"location":"release-notes/#breaking-changes_4","text":"added BackendStorage for dynamodb, s3, file and http (with @kylebarron) added MosaicJSON pydantic model for internal mosaicjson representation (with @kylebarron and @geospatial-jeff)","title":"Breaking changes"},{"location":"release-notes/#201-2020-01-28","text":"Bug fix, use pygeos from pypi instead of git repo","title":"2.0.1 (2020-01-28)"},{"location":"release-notes/#200-2020-01-28-major-refactor","text":"remove stack related code (lambda handler, serverless) switch to pygeos (#24) bug fixes add last pixel_method","title":"2.0.0 (2020-01-28) - Major refactor"},{"location":"release-notes/#100-2019-12-13","text":"add tif output fix overview creation add other Web templates","title":"1.0.0 (2019-12-13)"},{"location":"release-notes/#030-2019-11-07","text":"use aws lambda layer add update_mosaic utility function add /tiles/point endpoint to get points values from a mosaic add logs for mosaic creation add custom pixel methods add custom color maps","title":"0.3.0 (2019-11-07)"},{"location":"release-notes/#breaking-changes_5","text":"rename /mosaic/info/<mosaicid> to /mosaic/<mosaicid>/info","title":"Breaking changes"},{"location":"release-notes/#020-2019-09-30","text":"update for lambda-proxy~=5.0 (#15) add minimum_tile_cover option for mosaic creation (#16) add tile_cover_sort option (#16) add verbosity for cli","title":"0.2.0 (2019-09-30)"},{"location":"release-notes/#010-2019-09-05","text":"add /create.html endpoint (#14) update to remotepixel/amazonlinux docker image","title":"0.1.0 (2019-09-05)"},{"location":"v3_migration/","text":"cogeo-mosaic 2.0 to 3.0 migration guide \u00b6 MosaicJSON pydantic model \u00b6 We now use pydantic to define the MosaicJSON document. Pydantic From Pydantic docs: Define how data should be in pure, canonical python; validate it with pydantic. Pydantic model enforce the mosaicjson specification for the whole project by validating each items. from pydantic import BaseModel class MosaicJSON ( BaseModel ): \"\"\" MosaicJSON model. Based on https://github.com/developmentseed/mosaicjson-spec \"\"\" mosaicjson : str name : Optional [ str ] description : Optional [ str ] version : str = \"1.0.0\" attribution : Optional [ str ] minzoom : int = Field ( 0 , ge = 0 , le = 30 ) maxzoom : int = Field ( 30 , ge = 0 , le = 30 ) quadkey_zoom : Optional [ int ] bounds : List [ float ] = Field ([ - 180 , - 90 , 180 , 90 ]) center : Optional [ Tuple [ float , float , int ]] tiles : Dict [ str , List [ str ]] Validation \u00b6 mosaic_definition = dict ( mosaicjson = \"0.0.2\" , minzoom = 1 , maxzoom = 2 , quadkey_zoom = 1 , bounds = [ - 180 , - 90 , 180 , 90 ], center = ( 0 , 0 , 1 ), tiles = {}, ) m = MosaicJSON ( ** mosaic_definition ) > MosaicJSON ( mosaicjson = '0.0.2' , name = None , description = None , version = '1.0.0' , attribution = None , minzoom = 1 , maxzoom = 2 , quadkey_zoom = 1 , bounds = [ - 180.0 , - 90.0 , 180.0 , 90.0 ], center = ( 0.0 , 0.0 , 1 ), tiles = {}) # convert the mode to a dict m . dict ( exclude_none = True ) > { 'mosaicjson' : '0.0.2' , 'version' : '1.0.0' , 'minzoom' : 1 , 'maxzoom' : 2 , 'quadkey_zoom' : 1 , 'bounds' : [ - 180.0 , - 90.0 , 180.0 , 90.0 ], 'center' : ( 0.0 , 0.0 , 1 ), 'tiles' : {}} mosaic_definition = dict ( mosaicjson = \"0.0.2\" , minzoom = 1 , maxzoom = 100 , quadkey_zoom = 1 , bounds = [ - 180 , - 90 , 180 , 90 ], center = ( 0 , 0 , 1 ), tiles = {}, ) m = MosaicJSON ( ** mosaic_definition ) ... ValidationError : 1 validation error for MosaicJSON maxzoom ensure this value is less than or equal to 30 ( type = value_error . number . not_le ; limit_value = 30 ) Creation \u00b6 The MosaicJSON class comes also with helper functions: - MosaicJSON.from_urls : Create a mosaicjson from a set of COG urls - MosaicJSON.from_features : Create a mosaicjson from a set of GeoJSON features - MosaicJSON._create_mosaic (semi-private): Low level mosaic creation methods used by public methods ( from_urls and from_features ). #V2 from cogeo_mosaic.utils import create_mosaic mosaic_definition : Dict = create_mosaic ( dataset ) #V3 from cogeo_mosaic.mosaic import MosaicJSON mosaic_definition : MosaicJSON = MosaicJSON . from_urls ( dataset ) # or from a list of GeoJSON Features mosaic_definition : MosaicJSON = MosaicJSON . from_features ( dataset , minzoom = 1 , maxzoom = 3 ) To learn more about the low-level api checkout /docs/AdvancedTopics.md Backend Storage \u00b6 Read \u00b6 # V2 from cogeo_mosaic.utils import ( fetch_mosaic_definition , fetch_and_find_assets , fetch_and_find_assets_point , ) mosaic_definition = fetch_mosaic_definition ( url ) assets = fetch_and_find_assets ( url , x , y , z ) assets = fetch_and_find_assets_point ( url , lng , lat ) # V3 from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( url ) as mosaic : mosaic_definition = mosaic . mosaic_def assets = mosaic . tile ( x , y , z ) # LRU cache assets = mosaic . point ( lng , lat ) # LRU cache Write \u00b6 #V2 from cogeo_mosaic.utils import create_mosaic from boto3.session import Session as boto3_session mosaic_definition = create_mosaic ( dataset ) def _compress_gz_json ( data ): gzip_compress = zlib . compressobj ( 9 , zlib . DEFLATED , zlib . MAX_WBITS | 16 ) return ( gzip_compress . compress ( json . dumps ( data ) . encode ( \"utf-8\" )) + gzip_compress . flush () ) session = boto3_session () client = session . client ( \"s3\" ) client . put_object ( Bucket = bucket , Key = key , Body = _compress_gz_json ( mosaic_definition ), ) #V3 from cogeo_mosaic.mosaic import MosaicJSON mosaic_definition = MosaicJSON . from_urls ( dataset ) with MosaicBackend ( \"s3:// {bucket} / {key} \" , mosaic_def = mosaic_definition ) as mosaic : mosaic . write ()","title":"Migration to v3.0"},{"location":"v3_migration/#cogeo-mosaic-20-to-30-migration-guide","text":"","title":"cogeo-mosaic 2.0 to 3.0 migration guide"},{"location":"v3_migration/#mosaicjson-pydantic-model","text":"We now use pydantic to define the MosaicJSON document. Pydantic From Pydantic docs: Define how data should be in pure, canonical python; validate it with pydantic. Pydantic model enforce the mosaicjson specification for the whole project by validating each items. from pydantic import BaseModel class MosaicJSON ( BaseModel ): \"\"\" MosaicJSON model. Based on https://github.com/developmentseed/mosaicjson-spec \"\"\" mosaicjson : str name : Optional [ str ] description : Optional [ str ] version : str = \"1.0.0\" attribution : Optional [ str ] minzoom : int = Field ( 0 , ge = 0 , le = 30 ) maxzoom : int = Field ( 30 , ge = 0 , le = 30 ) quadkey_zoom : Optional [ int ] bounds : List [ float ] = Field ([ - 180 , - 90 , 180 , 90 ]) center : Optional [ Tuple [ float , float , int ]] tiles : Dict [ str , List [ str ]]","title":"MosaicJSON pydantic model"},{"location":"v3_migration/#validation","text":"mosaic_definition = dict ( mosaicjson = \"0.0.2\" , minzoom = 1 , maxzoom = 2 , quadkey_zoom = 1 , bounds = [ - 180 , - 90 , 180 , 90 ], center = ( 0 , 0 , 1 ), tiles = {}, ) m = MosaicJSON ( ** mosaic_definition ) > MosaicJSON ( mosaicjson = '0.0.2' , name = None , description = None , version = '1.0.0' , attribution = None , minzoom = 1 , maxzoom = 2 , quadkey_zoom = 1 , bounds = [ - 180.0 , - 90.0 , 180.0 , 90.0 ], center = ( 0.0 , 0.0 , 1 ), tiles = {}) # convert the mode to a dict m . dict ( exclude_none = True ) > { 'mosaicjson' : '0.0.2' , 'version' : '1.0.0' , 'minzoom' : 1 , 'maxzoom' : 2 , 'quadkey_zoom' : 1 , 'bounds' : [ - 180.0 , - 90.0 , 180.0 , 90.0 ], 'center' : ( 0.0 , 0.0 , 1 ), 'tiles' : {}} mosaic_definition = dict ( mosaicjson = \"0.0.2\" , minzoom = 1 , maxzoom = 100 , quadkey_zoom = 1 , bounds = [ - 180 , - 90 , 180 , 90 ], center = ( 0 , 0 , 1 ), tiles = {}, ) m = MosaicJSON ( ** mosaic_definition ) ... ValidationError : 1 validation error for MosaicJSON maxzoom ensure this value is less than or equal to 30 ( type = value_error . number . not_le ; limit_value = 30 )","title":"Validation"},{"location":"v3_migration/#creation","text":"The MosaicJSON class comes also with helper functions: - MosaicJSON.from_urls : Create a mosaicjson from a set of COG urls - MosaicJSON.from_features : Create a mosaicjson from a set of GeoJSON features - MosaicJSON._create_mosaic (semi-private): Low level mosaic creation methods used by public methods ( from_urls and from_features ). #V2 from cogeo_mosaic.utils import create_mosaic mosaic_definition : Dict = create_mosaic ( dataset ) #V3 from cogeo_mosaic.mosaic import MosaicJSON mosaic_definition : MosaicJSON = MosaicJSON . from_urls ( dataset ) # or from a list of GeoJSON Features mosaic_definition : MosaicJSON = MosaicJSON . from_features ( dataset , minzoom = 1 , maxzoom = 3 ) To learn more about the low-level api checkout /docs/AdvancedTopics.md","title":"Creation"},{"location":"v3_migration/#backend-storage","text":"","title":"Backend Storage"},{"location":"v3_migration/#read","text":"# V2 from cogeo_mosaic.utils import ( fetch_mosaic_definition , fetch_and_find_assets , fetch_and_find_assets_point , ) mosaic_definition = fetch_mosaic_definition ( url ) assets = fetch_and_find_assets ( url , x , y , z ) assets = fetch_and_find_assets_point ( url , lng , lat ) # V3 from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( url ) as mosaic : mosaic_definition = mosaic . mosaic_def assets = mosaic . tile ( x , y , z ) # LRU cache assets = mosaic . point ( lng , lat ) # LRU cache","title":"Read"},{"location":"v3_migration/#write","text":"#V2 from cogeo_mosaic.utils import create_mosaic from boto3.session import Session as boto3_session mosaic_definition = create_mosaic ( dataset ) def _compress_gz_json ( data ): gzip_compress = zlib . compressobj ( 9 , zlib . DEFLATED , zlib . MAX_WBITS | 16 ) return ( gzip_compress . compress ( json . dumps ( data ) . encode ( \"utf-8\" )) + gzip_compress . flush () ) session = boto3_session () client = session . client ( \"s3\" ) client . put_object ( Bucket = bucket , Key = key , Body = _compress_gz_json ( mosaic_definition ), ) #V3 from cogeo_mosaic.mosaic import MosaicJSON mosaic_definition = MosaicJSON . from_urls ( dataset ) with MosaicBackend ( \"s3:// {bucket} / {key} \" , mosaic_def = mosaic_definition ) as mosaic : mosaic . write ()","title":"Write"},{"location":"API/cache/","text":"module cogeo_mosaic. cache cogeo-mosaic cache configuration Attributes cache_config \u2014 Classes CacheSettings \u2014 Application settings class cogeo_mosaic.cache. CacheSettings ( _env_file='<object object at 0x7ffa2f654f70>' , _env_file_encoding=None , _secrets_dir=None , ttl=300 , maxsize=512 , disable=False ) Bases pydantic.env_settings.BaseSettings pydantic.main.BaseModel pydantic.utils.Representation Application settings Parameters _env_file (Path, str, or NoneType, optional) \u2014 _env_file_encoding (str, optional) \u2014 _secrets_dir (Path, str, or NoneType, optional) \u2014 ttl (int, optional) \u2014 maxsize (int, optional) \u2014 disable (bool, optional) \u2014 Classes Config \u2014 model config Config \u2014 model config Methods check_enable ( values ) \u2014 Check if cache is desabled. class Config ( ) model config class cogeo_mosaic.cache. Config ( ) Bases cogeo_mosaic.cache.CacheSettings.Config cogeo_mosaic.cache.Config importlib._bootstrap.Config pydantic.env_settings.BaseSettings.Config pydantic.main.BaseConfig model config classmethod check_enable ( values ) Check if cache is desabled. Parameters values \u2014","title":"Cache"},{"location":"API/mosaic/","text":"module cogeo_mosaic. mosaic cogeo_mosaic.mosaic MosaicJSON models and helper functions. Classes MosaicJSON \u2014 MosaicJSON model. Functions default_accessor ( feature ) \u2014 Return specific feature identifier. default_filter ( tile , dataset , geoms , minimum_tile_cover , tile_cover_sort , maximum_items_per_tile ) (list) \u2014 Filter and/or sort dataset per intersection coverage. function cogeo_mosaic.mosaic. default_accessor ( feature ) Return specific feature identifier. Parameters feature (dict) \u2014 function cogeo_mosaic.mosaic. default_filter ( tile , dataset , geoms , minimum_tile_cover=None , tile_cover_sort=False , maximum_items_per_tile=None ) \u2192 list Filter and/or sort dataset per intersection coverage. Parameters tile (Tile) \u2014 dataset (sequence of dict) \u2014 geoms (sequence of polygons) \u2014 minimum_tile_cover (float, optional) \u2014 tile_cover_sort (bool, optional) \u2014 maximum_items_per_tile (int, optional) \u2014 class cogeo_mosaic.mosaic. MosaicJSON ( mosaicjson , name=None , description=None , version='1.0.0' , attribution=None , minzoom=0 , maxzoom=30 , quadkey_zoom=None , bounds=[-180, -90, 180, 90] , center=None , tiles ) Bases pydantic.main.BaseModel pydantic.utils.Representation MosaicJSON model. Based on developmentseed/mosaicjson-spec Parameters mosaicjson (str) \u2014 name (str, optional) \u2014 description (str, optional) \u2014 version (str, optional) \u2014 attribution (str, optional) \u2014 minzoom (ConstrainedIntValue, optional) \u2014 maxzoom (ConstrainedIntValue, optional) \u2014 quadkey_zoom (int, optional) \u2014 bounds (list of float, optional) \u2014 center (float, float, int), optional \u2014 tiles (dict(str: list of str)) \u2014 Attributes version \u2014 Classes Config \u2014 Validate model on update. Config \u2014 Validate model on update. Methods compute_center ( values ) \u2014 Compute center if it does not exist. from_features ( features , minzoom , maxzoom , **kwargs ) (mosaic_definition (MosaicJSON)) \u2014 Create mosaicjson from a set of GeoJSON Features. from_urls ( urls , minzoom , maxzoom , max_threads , quiet , **kwargs ) (mosaic_definition (MosaicJSON)) \u2014 Create mosaicjson from COG urls. class Config ( ) Validate model on update. class cogeo_mosaic.mosaic. Config ( ) Bases cogeo_mosaic.mosaic.MosaicJSON.Config pydantic.main.BaseConfig Validate model on update. classmethod compute_center ( values ) Compute center if it does not exist. Parameters values \u2014 classmethod from_urls ( urls , minzoom=None , maxzoom=None , max_threads=20 , quiet=True , **kwargs ) Create mosaicjson from COG urls. Parameters urls (sequence of str) \u2014 minzoom (int, optional) \u2014 maxzoom (int, optional) \u2014 max_threads (int, optional) \u2014 quiet (bool, optional) \u2014 **kwargs \u2014 Attributes kwargs (any) \u2014 Options forwarded to MosaicJSON._create_mosaic max_threads (int) \u2014 Max threads to use (default: 20). maxzoom (int) \u2014 Force mosaic max-zoom. minzoom (int) \u2014 Force mosaic min-zoom. quiet (bool) \u2014 Mask processing steps (default is True). urls (list) \u2014 List of COGs. Returns (mosaic_definition (MosaicJSON)) Mosaic definition. Raises Exception \u2014 If COGs don't have the same datatype Examples >>> MosaicJSON . from_urls ([ \"1.tif\" , \"2.tif\" ]) classmethod from_features ( features , minzoom , maxzoom , **kwargs ) Create mosaicjson from a set of GeoJSON Features. Parameters features (sequence of dict) \u2014 minzoom (int) \u2014 maxzoom (int) \u2014 **kwargs \u2014 Attributes features (list) \u2014 List of GeoJSON features. kwargs (any) \u2014 Options forwarded to MosaicJSON._create_mosaic maxzoom (int) \u2014 Force mosaic max-zoom. minzoom (int) \u2014 Force mosaic min-zoom. Returns (mosaic_definition (MosaicJSON)) Mosaic definition. Examples >>> MosaicJSON . from_features ([{}, {}], 12 , 14 )","title":"MosaicJSON"},{"location":"API/backends/DynamoDB/","text":"class cogeo_mosaic.backends.dynamodb. DynamoDBBackend ( path , mosaic_def=None , reader=<class 'rio_tiler.io.cogeo.COGReader'> , reader_options=NOTHING , backend_options=NOTHING , client=None , region='us-east-1' ) Bases cogeo_mosaic.backends.base.BaseBackend rio_tiler.io.base.BaseReader rio_tiler.io.base.SpatialMixin DynamoDB Backend Adapter. Parameters path (str) \u2014 mosaic_def (MosaicJSON, optional) \u2014 reader (type of BaseReader, optional) \u2014 reader_options (dict, optional) \u2014 backend_options (dict, optional) \u2014 client (any, optional) \u2014 region (str, optional) \u2014 Attributes bounds \u2014 center \u2014 Return center from the mosaic definition. client \u2014 maxzoom \u2014 metadata \u2014 Retrieve Mosaic metadata minzoom \u2014 mosaic_def \u2014 mosaic_def.bounds \u2014 mosaic_def.center \u2014 mosaic_name \u2014 mosaicid (str) \u2014 Return sha224 id of the mosaicjson document. quadkey_zoom (int) \u2014 Return Quadkey zoom property. region \u2014 spatial_info (SpatialInfo) \u2014 Return Dataset's spatial info. table \u2014 table_name \u2014 Methods __attrs_post_init__ ( ) \u2014 Post Init: parse path, create client and connect to Table. __enter__ ( ) \u2014 Support using with Context Managers. __exit__ ( exc_type , exc_value , traceback ) \u2014 Support using with Context Managers. assets_for_point ( lng , lat ) (list of str) \u2014 Retrieve assets for point. assets_for_tile ( x , y , z ) (list of str) \u2014 Retrieve assets for tile. delete ( ) \u2014 Delete all items for a specific mosaic in the dynamoDB Table. feature ( ) \u2014 PlaceHolder for BaseReader.feature. get_assets ( x , y , z ) (list of str) \u2014 Find assets. info ( quadkeys ) (Info) \u2014 Mosaic info. part ( ) \u2014 PlaceHolder for BaseReader.part. point ( lon , lat , threads , reverse , **kwargs ) (list of dict) \u2014 Get Point value from multiple observation. preview ( ) \u2014 PlaceHolder for BaseReader.preview. stats ( ) \u2014 PlaceHolder for BaseReader.stats. tile ( x , y , z , reverse , **kwargs ) (ImageData, list of str) \u2014 Get Tile from multiple observation. tile_exists ( tile_z , tile_x , tile_y ) (bool) \u2014 Check if a tile is inside a the dataset bounds. update ( features , add_first , quiet , **kwargs ) \u2014 Update existing MosaicJSON on backend. write ( overwrite , **kwargs ) (dict) \u2014 Write mosaicjson document to AWS DynamoDB. method tile_exists ( tile_z , tile_x , tile_y ) \u2192 bool Check if a tile is inside a the dataset bounds. Parameters tile_z (int) \u2014 tile_x (int) \u2014 tile_y (int) \u2014 method __enter__ ( ) Support using with Context Managers. method __exit__ ( exc_type , exc_value , traceback ) Support using with Context Managers. Parameters exc_type \u2014 exc_value \u2014 traceback \u2014 method info ( quadkeys=False ) \u2192 Info Mosaic info. Parameters quadkeys (bool, optional) \u2014 method stats ( ) PlaceHolder for BaseReader.stats. method assets_for_tile ( x , y , z ) \u2192 list of str Retrieve assets for tile. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method assets_for_point ( lng , lat ) \u2192 list of str Retrieve assets for point. Parameters lng (float) \u2014 lat (float) \u2014 method tile ( x , y , z , reverse=False , **kwargs ) \u2192 (ImageData, list of str) Get Tile from multiple observation. Parameters **kwargs (any) \u2014 x (int) \u2014 y (int) \u2014 z (int) \u2014 reverse (bool, optional) \u2014 method point ( lon , lat , threads=10 , reverse=False , **kwargs ) \u2192 list of dict Get Point value from multiple observation. Parameters lon (float) \u2014 lat (float) \u2014 **kwargs (any) \u2014 threads (optional) \u2014 reverse (bool, optional) \u2014 method preview ( ) PlaceHolder for BaseReader.preview. method part ( ) PlaceHolder for BaseReader.part. method feature ( ) PlaceHolder for BaseReader.feature. method __attrs_post_init__ ( ) Post Init: parse path, create client and connect to Table. A path looks like dynamodb://{region}/{table_name}:{mosaic_name} dynamodb:///{table_name}:{mosaic_name} method write ( overwrite=False , **kwargs ) Write mosaicjson document to AWS DynamoDB. Parameters overwrite (bool) \u2014 delete old mosaic items inthe Table. **kwargs (any) \u2014 Options forwarded to dynamodb.create_table Returns (dict) dictionary with metadata constructed from the sceneid. Raises MosaicExistsError \u2014 If mosaic already exists in the Table. method update ( features , add_first=True , quiet=False , **kwargs ) Update existing MosaicJSON on backend. Parameters features (sequence of dict) \u2014 add_first (bool, optional) \u2014 quiet (bool, optional) \u2014 **kwargs \u2014 method get_assets ( x , y , z ) \u2192 list of str Find assets. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method delete ( ) Delete all items for a specific mosaic in the dynamoDB Table.","title":"DynamoDB"},{"location":"API/backends/File/","text":"class cogeo_mosaic.backends.file. FileBackend ( path , mosaic_def=None , reader=<class 'rio_tiler.io.cogeo.COGReader'> , reader_options=NOTHING , backend_options=NOTHING ) Bases cogeo_mosaic.backends.base.BaseBackend rio_tiler.io.base.BaseReader rio_tiler.io.base.SpatialMixin Local File Backend Adapter Parameters path (str) \u2014 mosaic_def (MosaicJSON, optional) \u2014 reader (type of BaseReader, optional) \u2014 reader_options (dict, optional) \u2014 backend_options (dict, optional) \u2014 Attributes _file_byte_size \u2014 bounds \u2014 center \u2014 Return center from the mosaic definition. maxzoom \u2014 metadata \u2014 Retrieve Mosaic metadata minzoom \u2014 mosaic_def \u2014 mosaic_def.bounds \u2014 mosaic_def.center \u2014 mosaicid (str) \u2014 Return sha224 id of the mosaicjson document. quadkey_zoom (int) \u2014 Return Quadkey zoom property. spatial_info (SpatialInfo) \u2014 Return Dataset's spatial info. Methods __attrs_post_init__ ( ) \u2014 Post Init: if not passed in init, try to read from self.path. __enter__ ( ) \u2014 Support using with Context Managers. __exit__ ( exc_type , exc_value , traceback ) \u2014 Support using with Context Managers. assets_for_point ( lng , lat ) (list of str) \u2014 Retrieve assets for point. assets_for_tile ( x , y , z ) (list of str) \u2014 Retrieve assets for tile. feature ( ) \u2014 PlaceHolder for BaseReader.feature. get_assets ( x , y , z ) (list of str) \u2014 Find assets. info ( quadkeys ) (Info) \u2014 Mosaic info. part ( ) \u2014 PlaceHolder for BaseReader.part. point ( lon , lat , threads , reverse , **kwargs ) (list of dict) \u2014 Get Point value from multiple observation. preview ( ) \u2014 PlaceHolder for BaseReader.preview. stats ( ) \u2014 PlaceHolder for BaseReader.stats. tile ( x , y , z , reverse , **kwargs ) (ImageData, list of str) \u2014 Get Tile from multiple observation. tile_exists ( tile_z , tile_x , tile_y ) (bool) \u2014 Check if a tile is inside a the dataset bounds. update ( features , add_first , quiet , **kwargs ) \u2014 Update existing MosaicJSON on backend. write ( overwrite , gzip ) \u2014 Write mosaicjson document to a file. method tile_exists ( tile_z , tile_x , tile_y ) \u2192 bool Check if a tile is inside a the dataset bounds. Parameters tile_z (int) \u2014 tile_x (int) \u2014 tile_y (int) \u2014 method __enter__ ( ) Support using with Context Managers. method __exit__ ( exc_type , exc_value , traceback ) Support using with Context Managers. Parameters exc_type \u2014 exc_value \u2014 traceback \u2014 method __attrs_post_init__ ( ) Post Init: if not passed in init, try to read from self.path. method info ( quadkeys=False ) \u2192 Info Mosaic info. Parameters quadkeys (bool, optional) \u2014 method stats ( ) PlaceHolder for BaseReader.stats. method assets_for_tile ( x , y , z ) \u2192 list of str Retrieve assets for tile. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method assets_for_point ( lng , lat ) \u2192 list of str Retrieve assets for point. Parameters lng (float) \u2014 lat (float) \u2014 method get_assets ( x , y , z ) \u2192 list of str Find assets. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method tile ( x , y , z , reverse=False , **kwargs ) \u2192 (ImageData, list of str) Get Tile from multiple observation. Parameters **kwargs (any) \u2014 x (int) \u2014 y (int) \u2014 z (int) \u2014 reverse (bool, optional) \u2014 method point ( lon , lat , threads=10 , reverse=False , **kwargs ) \u2192 list of dict Get Point value from multiple observation. Parameters lon (float) \u2014 lat (float) \u2014 **kwargs (any) \u2014 threads (optional) \u2014 reverse (bool, optional) \u2014 method preview ( ) PlaceHolder for BaseReader.preview. method part ( ) PlaceHolder for BaseReader.part. method feature ( ) PlaceHolder for BaseReader.feature. method update ( features , add_first=True , quiet=False , **kwargs ) Update existing MosaicJSON on backend. Parameters features (sequence of dict) \u2014 add_first (bool, optional) \u2014 quiet (bool, optional) \u2014 **kwargs \u2014 method write ( overwrite=False , gzip=None ) Write mosaicjson document to a file. Parameters overwrite (bool, optional) \u2014 gzip (bool, optional) \u2014","title":"File"},{"location":"API/backends/HTTP/","text":"class cogeo_mosaic.backends.web. HttpBackend ( path , mosaic_def=None , reader=<class 'rio_tiler.io.cogeo.COGReader'> , reader_options=NOTHING , backend_options=NOTHING ) Bases cogeo_mosaic.backends.base.BaseBackend rio_tiler.io.base.BaseReader rio_tiler.io.base.SpatialMixin Http/Https Backend Adapter Parameters path (str) \u2014 mosaic_def (MosaicJSON, optional) \u2014 reader (type of BaseReader, optional) \u2014 reader_options (dict, optional) \u2014 backend_options (dict, optional) \u2014 Attributes _file_byte_size \u2014 bounds \u2014 center \u2014 Return center from the mosaic definition. maxzoom \u2014 metadata \u2014 Retrieve Mosaic metadata minzoom \u2014 mosaic_def \u2014 mosaic_def.bounds \u2014 mosaic_def.center \u2014 mosaicid (str) \u2014 Return sha224 id of the mosaicjson document. quadkey_zoom (int) \u2014 Return Quadkey zoom property. spatial_info (SpatialInfo) \u2014 Return Dataset's spatial info. Methods __attrs_post_init__ ( ) \u2014 Post Init: if not passed in init, try to read from self.path. __enter__ ( ) \u2014 Support using with Context Managers. __exit__ ( exc_type , exc_value , traceback ) \u2014 Support using with Context Managers. assets_for_point ( lng , lat ) (list of str) \u2014 Retrieve assets for point. assets_for_tile ( x , y , z ) (list of str) \u2014 Retrieve assets for tile. feature ( ) \u2014 PlaceHolder for BaseReader.feature. get_assets ( x , y , z ) (list of str) \u2014 Find assets. info ( quadkeys ) (Info) \u2014 Mosaic info. part ( ) \u2014 PlaceHolder for BaseReader.part. point ( lon , lat , threads , reverse , **kwargs ) (list of dict) \u2014 Get Point value from multiple observation. preview ( ) \u2014 PlaceHolder for BaseReader.preview. stats ( ) \u2014 PlaceHolder for BaseReader.stats. tile ( x , y , z , reverse , **kwargs ) (ImageData, list of str) \u2014 Get Tile from multiple observation. tile_exists ( tile_z , tile_x , tile_y ) (bool) \u2014 Check if a tile is inside a the dataset bounds. update ( *args , **kwargs ) \u2014 Update the mosaicjson document. write ( ) \u2014 Write mosaicjson document. method tile_exists ( tile_z , tile_x , tile_y ) \u2192 bool Check if a tile is inside a the dataset bounds. Parameters tile_z (int) \u2014 tile_x (int) \u2014 tile_y (int) \u2014 method __enter__ ( ) Support using with Context Managers. method __exit__ ( exc_type , exc_value , traceback ) Support using with Context Managers. Parameters exc_type \u2014 exc_value \u2014 traceback \u2014 method __attrs_post_init__ ( ) Post Init: if not passed in init, try to read from self.path. method info ( quadkeys=False ) \u2192 Info Mosaic info. Parameters quadkeys (bool, optional) \u2014 method stats ( ) PlaceHolder for BaseReader.stats. method assets_for_tile ( x , y , z ) \u2192 list of str Retrieve assets for tile. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method assets_for_point ( lng , lat ) \u2192 list of str Retrieve assets for point. Parameters lng (float) \u2014 lat (float) \u2014 method get_assets ( x , y , z ) \u2192 list of str Find assets. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method tile ( x , y , z , reverse=False , **kwargs ) \u2192 (ImageData, list of str) Get Tile from multiple observation. Parameters **kwargs (any) \u2014 x (int) \u2014 y (int) \u2014 z (int) \u2014 reverse (bool, optional) \u2014 method point ( lon , lat , threads=10 , reverse=False , **kwargs ) \u2192 list of dict Get Point value from multiple observation. Parameters lon (float) \u2014 lat (float) \u2014 **kwargs (any) \u2014 threads (optional) \u2014 reverse (bool, optional) \u2014 method preview ( ) PlaceHolder for BaseReader.preview. method part ( ) PlaceHolder for BaseReader.part. method feature ( ) PlaceHolder for BaseReader.feature. method write ( ) Write mosaicjson document. method update ( *args , **kwargs ) Update the mosaicjson document. Parameters **kwargs (any) \u2014 *args \u2014","title":"HTTP"},{"location":"API/backends/S3/","text":"class cogeo_mosaic.backends.s3. S3Backend ( path , mosaic_def=None , reader=<class 'rio_tiler.io.cogeo.COGReader'> , reader_options=NOTHING , backend_options=NOTHING , client=None ) Bases cogeo_mosaic.backends.base.BaseBackend rio_tiler.io.base.BaseReader rio_tiler.io.base.SpatialMixin S3 Backend Adapter Parameters path (str) \u2014 mosaic_def (MosaicJSON, optional) \u2014 reader (type of BaseReader, optional) \u2014 reader_options (dict, optional) \u2014 backend_options (dict, optional) \u2014 client (any, optional) \u2014 Attributes _file_byte_size \u2014 bounds \u2014 bucket \u2014 center \u2014 Return center from the mosaic definition. client \u2014 key \u2014 maxzoom \u2014 metadata \u2014 Retrieve Mosaic metadata minzoom \u2014 mosaic_def \u2014 mosaic_def.bounds \u2014 mosaic_def.center \u2014 mosaicid (str) \u2014 Return sha224 id of the mosaicjson document. quadkey_zoom (int) \u2014 Return Quadkey zoom property. spatial_info (SpatialInfo) \u2014 Return Dataset's spatial info. Methods __attrs_post_init__ ( ) \u2014 Post Init: parse path and create client. __enter__ ( ) \u2014 Support using with Context Managers. __exit__ ( exc_type , exc_value , traceback ) \u2014 Support using with Context Managers. assets_for_point ( lng , lat ) (list of str) \u2014 Retrieve assets for point. assets_for_tile ( x , y , z ) (list of str) \u2014 Retrieve assets for tile. feature ( ) \u2014 PlaceHolder for BaseReader.feature. get_assets ( x , y , z ) (list of str) \u2014 Find assets. info ( quadkeys ) (Info) \u2014 Mosaic info. part ( ) \u2014 PlaceHolder for BaseReader.part. point ( lon , lat , threads , reverse , **kwargs ) (list of dict) \u2014 Get Point value from multiple observation. preview ( ) \u2014 PlaceHolder for BaseReader.preview. stats ( ) \u2014 PlaceHolder for BaseReader.stats. tile ( x , y , z , reverse , **kwargs ) (ImageData, list of str) \u2014 Get Tile from multiple observation. tile_exists ( tile_z , tile_x , tile_y ) (bool) \u2014 Check if a tile is inside a the dataset bounds. update ( features , add_first , quiet , **kwargs ) \u2014 Update existing MosaicJSON on backend. write ( overwrite , gzip , **kwargs ) \u2014 Write mosaicjson document to AWS S3. method tile_exists ( tile_z , tile_x , tile_y ) \u2192 bool Check if a tile is inside a the dataset bounds. Parameters tile_z (int) \u2014 tile_x (int) \u2014 tile_y (int) \u2014 method __enter__ ( ) Support using with Context Managers. method __exit__ ( exc_type , exc_value , traceback ) Support using with Context Managers. Parameters exc_type \u2014 exc_value \u2014 traceback \u2014 method info ( quadkeys=False ) \u2192 Info Mosaic info. Parameters quadkeys (bool, optional) \u2014 method stats ( ) PlaceHolder for BaseReader.stats. method assets_for_tile ( x , y , z ) \u2192 list of str Retrieve assets for tile. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method assets_for_point ( lng , lat ) \u2192 list of str Retrieve assets for point. Parameters lng (float) \u2014 lat (float) \u2014 method get_assets ( x , y , z ) \u2192 list of str Find assets. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method tile ( x , y , z , reverse=False , **kwargs ) \u2192 (ImageData, list of str) Get Tile from multiple observation. Parameters **kwargs (any) \u2014 x (int) \u2014 y (int) \u2014 z (int) \u2014 reverse (bool, optional) \u2014 method point ( lon , lat , threads=10 , reverse=False , **kwargs ) \u2192 list of dict Get Point value from multiple observation. Parameters lon (float) \u2014 lat (float) \u2014 **kwargs (any) \u2014 threads (optional) \u2014 reverse (bool, optional) \u2014 method preview ( ) PlaceHolder for BaseReader.preview. method part ( ) PlaceHolder for BaseReader.part. method feature ( ) PlaceHolder for BaseReader.feature. method update ( features , add_first=True , quiet=False , **kwargs ) Update existing MosaicJSON on backend. Parameters features (sequence of dict) \u2014 add_first (bool, optional) \u2014 quiet (bool, optional) \u2014 **kwargs \u2014 method __attrs_post_init__ ( ) Post Init: parse path and create client. method write ( overwrite=False , gzip=None , **kwargs ) Write mosaicjson document to AWS S3. Parameters overwrite (bool, optional) \u2014 gzip (bool, optional) \u2014 **kwargs (any) \u2014","title":"s3"},{"location":"API/backends/STAC/","text":"class cogeo_mosaic.backends.stac. STACBackend ( path , query , minzoom , maxzoom , mosaic_def=None , reader=<class 'rio_tiler.io.stac.STACReader'> , reader_options=NOTHING , backend_options=NOTHING ) Bases cogeo_mosaic.backends.base.BaseBackend rio_tiler.io.base.BaseReader rio_tiler.io.base.SpatialMixin STAC Backend Adapter Parameters path (str) \u2014 mosaic_def (MosaicJSON, optional) \u2014 reader (type of STACReader, optional) \u2014 reader_options (dict, optional) \u2014 backend_options (dict, optional) \u2014 query (dict) \u2014 minzoom (int) \u2014 maxzoom (int) \u2014 Attributes bounds \u2014 center \u2014 Return center from the mosaic definition. maxzoom \u2014 metadata \u2014 Retrieve Mosaic metadata minzoom \u2014 mosaic_def \u2014 mosaic_def.bounds \u2014 mosaic_def.center \u2014 mosaicid (str) \u2014 Return sha224 id of the mosaicjson document. quadkey_zoom (int) \u2014 Return Quadkey zoom property. spatial_info (SpatialInfo) \u2014 Return Dataset's spatial info. Examples >>> with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , query , 8 , 15 , ) as mosaic : mosaic . tile ( 0 , 0 , 0 ) Methods __attrs_post_init__ ( ) \u2014 Post Init: if not passed in init, try to read from self.path. __enter__ ( ) \u2014 Support using with Context Managers. __exit__ ( exc_type , exc_value , traceback ) \u2014 Support using with Context Managers. assets_for_point ( lng , lat ) (list of str) \u2014 Retrieve assets for point. assets_for_tile ( x , y , z ) (list of str) \u2014 Retrieve assets for tile. feature ( ) \u2014 PlaceHolder for BaseReader.feature. get_assets ( x , y , z ) (list of str) \u2014 Find assets. info ( quadkeys ) (Info) \u2014 Mosaic info. part ( ) \u2014 PlaceHolder for BaseReader.part. point ( lon , lat , threads , reverse , **kwargs ) (list of dict) \u2014 Get Point value from multiple observation. preview ( ) \u2014 PlaceHolder for BaseReader.preview. stats ( ) \u2014 PlaceHolder for BaseReader.stats. tile ( x , y , z , reverse , **kwargs ) (ImageData, list of str) \u2014 Get Tile from multiple observation. tile_exists ( tile_z , tile_x , tile_y ) (bool) \u2014 Check if a tile is inside a the dataset bounds. update ( *args , **kwargs ) \u2014 Update the mosaicjson document. write ( ) \u2014 Write mosaicjson document. method tile_exists ( tile_z , tile_x , tile_y ) \u2192 bool Check if a tile is inside a the dataset bounds. Parameters tile_z (int) \u2014 tile_x (int) \u2014 tile_y (int) \u2014 method __enter__ ( ) Support using with Context Managers. method __exit__ ( exc_type , exc_value , traceback ) Support using with Context Managers. Parameters exc_type \u2014 exc_value \u2014 traceback \u2014 method info ( quadkeys=False ) \u2192 Info Mosaic info. Parameters quadkeys (bool, optional) \u2014 method stats ( ) PlaceHolder for BaseReader.stats. method assets_for_tile ( x , y , z ) \u2192 list of str Retrieve assets for tile. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method assets_for_point ( lng , lat ) \u2192 list of str Retrieve assets for point. Parameters lng (float) \u2014 lat (float) \u2014 method get_assets ( x , y , z ) \u2192 list of str Find assets. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method tile ( x , y , z , reverse=False , **kwargs ) \u2192 (ImageData, list of str) Get Tile from multiple observation. Parameters **kwargs (any) \u2014 x (int) \u2014 y (int) \u2014 z (int) \u2014 reverse (bool, optional) \u2014 method point ( lon , lat , threads=10 , reverse=False , **kwargs ) \u2192 list of dict Get Point value from multiple observation. Parameters lon (float) \u2014 lat (float) \u2014 **kwargs (any) \u2014 threads (optional) \u2014 reverse (bool, optional) \u2014 method preview ( ) PlaceHolder for BaseReader.preview. method part ( ) PlaceHolder for BaseReader.part. method feature ( ) PlaceHolder for BaseReader.feature. method __attrs_post_init__ ( ) Post Init: if not passed in init, try to read from self.path. method write ( ) Write mosaicjson document. method update ( *args , **kwargs ) Update the mosaicjson document. Parameters **kwargs (any) \u2014 *args \u2014","title":"STAC"},{"location":"API/backends/base/","text":"abstract class cogeo_mosaic.backends.base. BaseBackend ( path , mosaic_def=None , reader=<class 'rio_tiler.io.cogeo.COGReader'> , reader_options=NOTHING , backend_options=NOTHING ) Bases rio_tiler.io.base.BaseReader rio_tiler.io.base.SpatialMixin Base Class for cogeo-mosaic backend storage. Parameters path (str) \u2014 mosaic_def (MosaicJSON, optional) \u2014 reader (type of BaseReader, optional) \u2014 reader_options (dict, optional) \u2014 backend_options (dict, optional) \u2014 Attributes bounds \u2014 center \u2014 Return center from the mosaic definition. maxzoom \u2014 metadata \u2014 Retrieve Mosaic metadata minzoom \u2014 mosaic_def \u2014 mosaic_def.bounds \u2014 mosaic_def.center \u2014 mosaicid (str) \u2014 Return sha224 id of the mosaicjson document. quadkey_zoom (int) \u2014 Return Quadkey zoom property. spatial_info (SpatialInfo) \u2014 Return Dataset's spatial info. Methods __attrs_post_init__ ( ) \u2014 Post Init: if not passed in init, try to read from self.path. __enter__ ( ) \u2014 Support using with Context Managers. __exit__ ( exc_type , exc_value , traceback ) \u2014 Support using with Context Managers. assets_for_point ( lng , lat ) (list of str) \u2014 Retrieve assets for point. assets_for_tile ( x , y , z ) (list of str) \u2014 Retrieve assets for tile. feature ( ) \u2014 PlaceHolder for BaseReader.feature. get_assets ( x , y , z ) (list of str) \u2014 Find assets. info ( quadkeys ) (Info) \u2014 Mosaic info. part ( ) \u2014 PlaceHolder for BaseReader.part. point ( lon , lat , threads , reverse , **kwargs ) (list of dict) \u2014 Get Point value from multiple observation. preview ( ) \u2014 PlaceHolder for BaseReader.preview. stats ( ) \u2014 PlaceHolder for BaseReader.stats. tile ( x , y , z , reverse , **kwargs ) (ImageData, list of str) \u2014 Get Tile from multiple observation. tile_exists ( tile_z , tile_x , tile_y ) (bool) \u2014 Check if a tile is inside a the dataset bounds. update ( features , add_first , quiet , **kwargs ) \u2014 Update existing MosaicJSON on backend. write ( overwrite ) \u2014 Upload new MosaicJSON to backend. method tile_exists ( tile_z , tile_x , tile_y ) \u2192 bool Check if a tile is inside a the dataset bounds. Parameters tile_z (int) \u2014 tile_x (int) \u2014 tile_y (int) \u2014 method __enter__ ( ) Support using with Context Managers. method __exit__ ( exc_type , exc_value , traceback ) Support using with Context Managers. Parameters exc_type \u2014 exc_value \u2014 traceback \u2014 method __attrs_post_init__ ( ) Post Init: if not passed in init, try to read from self.path. method info ( quadkeys=False ) \u2192 Info Mosaic info. Parameters quadkeys (bool, optional) \u2014 method stats ( ) PlaceHolder for BaseReader.stats. method assets_for_tile ( x , y , z ) \u2192 list of str Retrieve assets for tile. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method assets_for_point ( lng , lat ) \u2192 list of str Retrieve assets for point. Parameters lng (float) \u2014 lat (float) \u2014 method get_assets ( x , y , z ) \u2192 list of str Find assets. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 method tile ( x , y , z , reverse=False , **kwargs ) \u2192 (ImageData, list of str) Get Tile from multiple observation. Parameters x (int) \u2014 y (int) \u2014 z (int) \u2014 reverse (bool, optional) \u2014 **kwargs (any) \u2014 method point ( lon , lat , threads=10 , reverse=False , **kwargs ) \u2192 list of dict Get Point value from multiple observation. Parameters lon (float) \u2014 lat (float) \u2014 threads (optional) \u2014 reverse (bool, optional) \u2014 **kwargs (any) \u2014 method preview ( ) PlaceHolder for BaseReader.preview. method part ( ) PlaceHolder for BaseReader.part. method feature ( ) PlaceHolder for BaseReader.feature. abstract method write ( overwrite=True ) Upload new MosaicJSON to backend. Parameters overwrite (bool, optional) \u2014 method update ( features , add_first=True , quiet=False , **kwargs ) Update existing MosaicJSON on backend. Parameters features (sequence of dict) \u2014 add_first (bool, optional) \u2014 quiet (bool, optional) \u2014 **kwargs \u2014","title":"BaseClass"},{"location":"advanced/backends/","text":"Starting in version 3.0.0 , we introduced specific backend storage for: File (default, file:/// ) HTTP/HTTPS ( http:// , https:// ) AWS S3 ( s3:// ) AWS DynamoDB ( dynamodb://{region}/{table_name} ). If region is not passed, it reads the value of the AWS_REGION environment variable. If that environment variable does not exist, it falls back to us-east-1 . If you choose not to pass a region , you still need three / before the table name, like so dynamodb:///{table_name} . STAC ( stac+:https:// ). Based on SpatioTemporal Asset Catalog API. To ease the usage we added a helper function to use the right backend based on the uri schema: cogeo_mosaic.backends.MosaicBackend from cogeo_mosaic.backends import MosaicBackend with MosaicBackend ( \"s3://mybucket/amosaic.json\" ) as mosaic : assert isinstance ( mosaic , cogeo_mosaic . backends . s3 . S3Backend ) with MosaicBackend ( \"https://mosaic.com/amosaic.json.gz\" ) as mosaic : assert isinstance ( mosaic , cogeo_mosaic . backends . web . HttpBackend ) with MosaicBackend ( \"dynamodb://us-east-1/amosaic\" ) as mosaic : assert isinstance ( mosaic , cogeo_mosaic . backends . dynamodb . DynamoDBBackend ) with MosaicBackend ( \"file:///amosaic.json.gz\" ) as mosaic : assert isinstance ( mosaic , cogeo_mosaic . backends . file . FileBackend ) # Create only with MosaicBackend ( \"stac+https://my-stac.api/search\" , { \"collections\" : [ \"satellite\" ]}, 10 , 12 ) as mosaic : assert isinstance ( mosaic , cogeo_mosaic . backends . stac . STACBackend ) with MosaicBackend ( \"amosaic.json.gz\" ) as mosaic : assert isinstance ( mosaic , cogeo_mosaic . backends . file . FileBackend ) STAC Backend \u00b6 The STACBackend is purely dynamic, meaning it's not used to read or write a file. This backend will POST to the input url looking for STAC items which will then be used to create the mosaicJSON. import datetime import mercantile from cogeo_mosaic.backends.stac import STACBackend geojson = { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 30.810813903808594 , 29.454247067148533 ], [ 30.88600158691406 , 29.454247067148533 ], [ 30.88600158691406 , 29.51879923863822 ], [ 30.810813903808594 , 29.51879923863822 ], [ 30.810813903808594 , 29.454247067148533 ] ] ] } } ] } date_min = \"2019-01-01\" date_max = \"2019-12-11\" start = datetime . datetime . strptime ( date_min , \"%Y-%m- %d \" ) . strftime ( \"%Y-%m- %d T00:00:00Z\" ) end = datetime . datetime . strptime ( date_max , \"%Y-%m- %d \" ) . strftime ( \"%Y-%m- %d T23:59:59Z\" ) query = { \"collections\" : [ \"sentinel-s2-l2a-cogs\" ], \"datetime\" : f \" { start } / { end } \" , \"query\" : { \"eo:cloud_cover\" : { \"lt\" : 5 } }, \"intersects\" : geojson [ \"features\" ][ 0 ][ \"geometry\" ], \"limit\" : 1000 , \"fields\" : { 'include' : [ 'id' , 'properties.datetime' , 'properties.data_coverage' ], 'exclude' : [ 'assets' ] } } with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , query , 8 , 15 , ) as mosaic : print ( mosaic . metadata ) Specification \u00b6 The STACBackend rely on Spec version 1.0.0alpha. Paggination \u00b6 The returned object from the POST requests might not represent the whole results and thus we need to use the paggination. You can limit the pagination by using max_items or stac_query_limit options. Limit the total result to 1000 items with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , {}, 8 , 15 , max_items = 1000 , ) as mosaic : print ( mosaic . metadata ) Limit the size of each POST result with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , {}, 8 , 15 , stac_query_limit = 500 , ) as mosaic : print ( mosaic . metadata ) Warnings: trying to run the previous example will results in fetching the whole collection. Tile's asset \u00b6 MosaicJSON tile asset is defined using accessor option. By default the backend will try to construct or retrieve the Item url def default_stac_accessor ( feature : Dict ): \"\"\"Return feature identifier.\"\"\" link = list ( filter ( lambda link : link [ \"rel\" ] == \"self\" , feature [ \"links\" ])) if link : return link [ 0 ][ \"href\" ] link = list ( filter ( lambda link : link [ \"rel\" ] == \"root\" , feature [ \"links\" ])) if link : return os . path . join ( link [ 0 ][ \"href\" ], \"collections\" , feature [ \"collection\" ], \"items\" , feature [ \"id\" ], ) # Fall back to the item ID return feature [ \"id\" ] This default accessor function rely on the self or root link to be present. It's let to the user to built a Mosaic Tiler which will understand the asset. Custom accessor \u00b6 Accessor HAVE to be a callable which take a GeoJSON feature as input. Here is an example of an accessor that will return the ulr for asset B01 with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , {}, 8 , 15 , stac_query_limit = 500 , accessor = lambda x : x [ \"assets\" ][ \"B01\" ][ \"href\" ], ) as mosaic : print ( mosaic . metadata )","title":"Backends"},{"location":"advanced/backends/#stac-backend","text":"The STACBackend is purely dynamic, meaning it's not used to read or write a file. This backend will POST to the input url looking for STAC items which will then be used to create the mosaicJSON. import datetime import mercantile from cogeo_mosaic.backends.stac import STACBackend geojson = { \"type\" : \"FeatureCollection\" , \"features\" : [ { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ 30.810813903808594 , 29.454247067148533 ], [ 30.88600158691406 , 29.454247067148533 ], [ 30.88600158691406 , 29.51879923863822 ], [ 30.810813903808594 , 29.51879923863822 ], [ 30.810813903808594 , 29.454247067148533 ] ] ] } } ] } date_min = \"2019-01-01\" date_max = \"2019-12-11\" start = datetime . datetime . strptime ( date_min , \"%Y-%m- %d \" ) . strftime ( \"%Y-%m- %d T00:00:00Z\" ) end = datetime . datetime . strptime ( date_max , \"%Y-%m- %d \" ) . strftime ( \"%Y-%m- %d T23:59:59Z\" ) query = { \"collections\" : [ \"sentinel-s2-l2a-cogs\" ], \"datetime\" : f \" { start } / { end } \" , \"query\" : { \"eo:cloud_cover\" : { \"lt\" : 5 } }, \"intersects\" : geojson [ \"features\" ][ 0 ][ \"geometry\" ], \"limit\" : 1000 , \"fields\" : { 'include' : [ 'id' , 'properties.datetime' , 'properties.data_coverage' ], 'exclude' : [ 'assets' ] } } with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , query , 8 , 15 , ) as mosaic : print ( mosaic . metadata )","title":"STAC Backend"},{"location":"advanced/backends/#specification","text":"The STACBackend rely on Spec version 1.0.0alpha.","title":"Specification"},{"location":"advanced/backends/#paggination","text":"The returned object from the POST requests might not represent the whole results and thus we need to use the paggination. You can limit the pagination by using max_items or stac_query_limit options. Limit the total result to 1000 items with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , {}, 8 , 15 , max_items = 1000 , ) as mosaic : print ( mosaic . metadata ) Limit the size of each POST result with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , {}, 8 , 15 , stac_query_limit = 500 , ) as mosaic : print ( mosaic . metadata ) Warnings: trying to run the previous example will results in fetching the whole collection.","title":"Paggination"},{"location":"advanced/backends/#tiles-asset","text":"MosaicJSON tile asset is defined using accessor option. By default the backend will try to construct or retrieve the Item url def default_stac_accessor ( feature : Dict ): \"\"\"Return feature identifier.\"\"\" link = list ( filter ( lambda link : link [ \"rel\" ] == \"self\" , feature [ \"links\" ])) if link : return link [ 0 ][ \"href\" ] link = list ( filter ( lambda link : link [ \"rel\" ] == \"root\" , feature [ \"links\" ])) if link : return os . path . join ( link [ 0 ][ \"href\" ], \"collections\" , feature [ \"collection\" ], \"items\" , feature [ \"id\" ], ) # Fall back to the item ID return feature [ \"id\" ] This default accessor function rely on the self or root link to be present. It's let to the user to built a Mosaic Tiler which will understand the asset.","title":"Tile's asset"},{"location":"advanced/backends/#custom-accessor","text":"Accessor HAVE to be a callable which take a GeoJSON feature as input. Here is an example of an accessor that will return the ulr for asset B01 with STACBackend ( \"https://earth-search.aws.element84.com/v0/search\" , {}, 8 , 15 , stac_query_limit = 500 , accessor = lambda x : x [ \"assets\" ][ \"B01\" ][ \"href\" ], ) as mosaic : print ( mosaic . metadata )","title":"Custom accessor"},{"location":"advanced/custom/","text":"Custom mosaic creation \u00b6 MosaicJSON._create_mosaic() method is the low level method that creates mosaicjson document. It has multiple required arguments and options with default values which more advanced users would change. # cogeo_mosaic.mosaic.MosaicJSON._create_mosaic def _create_mosaic ( cls , features : Sequence [ Dict ], minzoom : int , maxzoom : int , quadkey_zoom : Optional [ int ] = None , accessor : Callable [[ Dict ], str ] = default_accessor , asset_filter : Callable = default_filter , version : str = \"0.0.2\" , quiet : bool = True , ** kwargs , ): Custom Accessor \u00b6 MosaicJSON create method takes a list of GeoJSON features has input, those can be the output of cogeo_mosaic.utils.get_footprints or can be provided by the user (e.g STAC items). MosaicJSON defines it's tile assets as a MUST be arrays of strings (url or sceneid) pointing to a COG . To access those values, _create_mosaic needs to know which property to read from the GeoJSON feature. The accessor option is here to enable user to pass their own accessor model. By default, _create_mosaic expect features from get_footprints and thus COG path stored in feature[\"properties\"][\"path\"] . Example: from cogeo_mosaic.mosaic import MosaicJSON features = [{ \"url\" : \"1.tif\" , \"geometry\" : { ... }}, { \"url\" : \"2.tif\" , \"geometry\" : { ... }}] minzoom = 1 maxzoom = 6 custom_id = lambda feature : feature [ \"url\" ] # 'from_features' will pass all args and kwargs to '_create_mosaic' mosaicjson = MosaicJSON . from_features ( features , minzoom , maxzoom , accessor = custom_id , ) Custom asset filtering \u00b6 On mosaicjson creation ones would want to perform more advanced assets filtering or sorting. To enable this, users can define their own filter method and pass it using the asset_filter options. !!! In the current implementation, asset_filter method have to allow at least 3 arguments: - tile - mercantile.Tile: Mercantile tile - dataset - Sequence[Dict]: GeoJSON Feature list intersecting with the tile - geoms - Sequence[polygons]: Geos Polygon list for the features Example: import datetime from cogeo_mosaic.mosaic import MosaicJSON , default_filter features = [{ \"url\" : \"20190101.tif\" , \"geometry\" : { ... }}, { \"url\" : \"20190102.tif\" , \"geometry\" : { ... }}] minzoom = 1 maxzoom = 6 def custom_filter ( ** args , ** kwargs ): \"\"\"Default filter + sort.\"\"\" dataset = default_filter ( ** args , ** kwargs ) return sorted ( dataset , key = lambda x : datetime . datetime . strptime ( x [ \"url\" ] . split ( \".\" )[ 0 ], \"%Y%m %d \" ) ) mosaicjson = MosaicJSON . from_features ( features , minzoom , maxzoom , asset_filter = custom_filter , ) Custom mosaic update \u00b6 Update method is backend specific because you don't write a mosaicjson document in the same way in AWS S3 and in AWS DynamoDB. The main method is defined in cogeo_mosaic.backends.base.BaseBackend . On update, here is what is happening: 1. create mosaic with the new dataset 2. loop through the new quadkeys and edit old mosaic assets 3. update bounds, center and version of the updated mosaic 4. write the mosaic # cogeo_mosaic.backends.base.BaseBackend def update ( self , features : Sequence [ Dict ], add_first : bool = True , quiet : bool = False , ** kwargs , ): \"\"\"Update existing MosaicJSON on backend.\"\"\" # Create mosaic with the new features new_mosaic = self . mosaic_def . from_features ( features , self . mosaic_def . minzoom , self . mosaic_def . maxzoom , quadkey_zoom = self . quadkey_zoom , quiet = quiet , ** kwargs , ) # Loop through the new `quadkeys` and edit `old` mosaic assets for quadkey , new_assets in new_mosaic . tiles . items (): tile = mercantile . quadkey_to_tile ( quadkey ) assets = self . tile ( * tile ) assets = [ * new_assets , * assets ] if add_first else [ * assets , * new_assets ] # [PLACEHOLDER] add custom sorting algorithm (e.g based on path name) self . mosaic_def . tiles [ quadkey ] = assets # Update bounds, center and version of the updated mosaic bounds = bbox_union ( new_mosaic . bounds , self . mosaic_def . bounds ) self . mosaic_def . _increase_version () # Increate mosaicjson document version self . mosaic_def . bounds = bounds self . mosaic_def . center = ( ( bounds [ 0 ] + bounds [ 2 ]) / 2 , ( bounds [ 1 ] + bounds [ 3 ]) / 2 , self . mosaic_def . minzoom , ) # Write the mosaic if self . path : self . write () return Sometime you'll will want to do more advanced filtering/sorting with the newly dataset stack (e.g keep a max number of COG). For this you'll need to create custom backend: from cogeo_mosaic.backends.s3 import S3Backend class CustomS3Backend ( S3Backend ): _backend_name = \"Custom AWS S3\" def update ( self , features : Sequence [ Dict ], quiet : bool = False , max_image : int = 5 , ** kwargs , ): \"\"\"Update existing MosaicJSON on backend.\"\"\" new_mosaic = self . mosaic_def . from_features ( features , self . mosaic_def . minzoom , self . mosaic_def . maxzoom , quadkey_zoom = self . quadkey_zoom , quiet = quiet , ** kwargs , ) for quadkey , new_assets in new_mosaic . tiles . items (): tile = mercantile . quadkey_to_tile ( quadkey ) assets = self . tile ( * tile ) assets = [ * new_assets , * assets ] self . mosaic_def . tiles [ quadkey ] = assets [: maximum_items_per_tile ] bounds = bbox_union ( new_mosaic . bounds , self . mosaic_def . bounds ) self . mosaic_def . _increase_version () # Increate mosaicjson document version self . mosaic_def . bounds = bounds self . mosaic_def . center = ( ( bounds [ 0 ] + bounds [ 2 ]) / 2 , ( bounds [ 1 ] + bounds [ 3 ]) / 2 , self . mosaic_def . minzoom , ) self . write () return","title":"Customization"},{"location":"advanced/custom/#custom-mosaic-creation","text":"MosaicJSON._create_mosaic() method is the low level method that creates mosaicjson document. It has multiple required arguments and options with default values which more advanced users would change. # cogeo_mosaic.mosaic.MosaicJSON._create_mosaic def _create_mosaic ( cls , features : Sequence [ Dict ], minzoom : int , maxzoom : int , quadkey_zoom : Optional [ int ] = None , accessor : Callable [[ Dict ], str ] = default_accessor , asset_filter : Callable = default_filter , version : str = \"0.0.2\" , quiet : bool = True , ** kwargs , ):","title":"Custom mosaic creation"},{"location":"advanced/custom/#custom-accessor","text":"MosaicJSON create method takes a list of GeoJSON features has input, those can be the output of cogeo_mosaic.utils.get_footprints or can be provided by the user (e.g STAC items). MosaicJSON defines it's tile assets as a MUST be arrays of strings (url or sceneid) pointing to a COG . To access those values, _create_mosaic needs to know which property to read from the GeoJSON feature. The accessor option is here to enable user to pass their own accessor model. By default, _create_mosaic expect features from get_footprints and thus COG path stored in feature[\"properties\"][\"path\"] . Example: from cogeo_mosaic.mosaic import MosaicJSON features = [{ \"url\" : \"1.tif\" , \"geometry\" : { ... }}, { \"url\" : \"2.tif\" , \"geometry\" : { ... }}] minzoom = 1 maxzoom = 6 custom_id = lambda feature : feature [ \"url\" ] # 'from_features' will pass all args and kwargs to '_create_mosaic' mosaicjson = MosaicJSON . from_features ( features , minzoom , maxzoom , accessor = custom_id , )","title":"Custom Accessor"},{"location":"advanced/custom/#custom-asset-filtering","text":"On mosaicjson creation ones would want to perform more advanced assets filtering or sorting. To enable this, users can define their own filter method and pass it using the asset_filter options. !!! In the current implementation, asset_filter method have to allow at least 3 arguments: - tile - mercantile.Tile: Mercantile tile - dataset - Sequence[Dict]: GeoJSON Feature list intersecting with the tile - geoms - Sequence[polygons]: Geos Polygon list for the features Example: import datetime from cogeo_mosaic.mosaic import MosaicJSON , default_filter features = [{ \"url\" : \"20190101.tif\" , \"geometry\" : { ... }}, { \"url\" : \"20190102.tif\" , \"geometry\" : { ... }}] minzoom = 1 maxzoom = 6 def custom_filter ( ** args , ** kwargs ): \"\"\"Default filter + sort.\"\"\" dataset = default_filter ( ** args , ** kwargs ) return sorted ( dataset , key = lambda x : datetime . datetime . strptime ( x [ \"url\" ] . split ( \".\" )[ 0 ], \"%Y%m %d \" ) ) mosaicjson = MosaicJSON . from_features ( features , minzoom , maxzoom , asset_filter = custom_filter , )","title":"Custom asset filtering"},{"location":"advanced/custom/#custom-mosaic-update","text":"Update method is backend specific because you don't write a mosaicjson document in the same way in AWS S3 and in AWS DynamoDB. The main method is defined in cogeo_mosaic.backends.base.BaseBackend . On update, here is what is happening: 1. create mosaic with the new dataset 2. loop through the new quadkeys and edit old mosaic assets 3. update bounds, center and version of the updated mosaic 4. write the mosaic # cogeo_mosaic.backends.base.BaseBackend def update ( self , features : Sequence [ Dict ], add_first : bool = True , quiet : bool = False , ** kwargs , ): \"\"\"Update existing MosaicJSON on backend.\"\"\" # Create mosaic with the new features new_mosaic = self . mosaic_def . from_features ( features , self . mosaic_def . minzoom , self . mosaic_def . maxzoom , quadkey_zoom = self . quadkey_zoom , quiet = quiet , ** kwargs , ) # Loop through the new `quadkeys` and edit `old` mosaic assets for quadkey , new_assets in new_mosaic . tiles . items (): tile = mercantile . quadkey_to_tile ( quadkey ) assets = self . tile ( * tile ) assets = [ * new_assets , * assets ] if add_first else [ * assets , * new_assets ] # [PLACEHOLDER] add custom sorting algorithm (e.g based on path name) self . mosaic_def . tiles [ quadkey ] = assets # Update bounds, center and version of the updated mosaic bounds = bbox_union ( new_mosaic . bounds , self . mosaic_def . bounds ) self . mosaic_def . _increase_version () # Increate mosaicjson document version self . mosaic_def . bounds = bounds self . mosaic_def . center = ( ( bounds [ 0 ] + bounds [ 2 ]) / 2 , ( bounds [ 1 ] + bounds [ 3 ]) / 2 , self . mosaic_def . minzoom , ) # Write the mosaic if self . path : self . write () return Sometime you'll will want to do more advanced filtering/sorting with the newly dataset stack (e.g keep a max number of COG). For this you'll need to create custom backend: from cogeo_mosaic.backends.s3 import S3Backend class CustomS3Backend ( S3Backend ): _backend_name = \"Custom AWS S3\" def update ( self , features : Sequence [ Dict ], quiet : bool = False , max_image : int = 5 , ** kwargs , ): \"\"\"Update existing MosaicJSON on backend.\"\"\" new_mosaic = self . mosaic_def . from_features ( features , self . mosaic_def . minzoom , self . mosaic_def . maxzoom , quadkey_zoom = self . quadkey_zoom , quiet = quiet , ** kwargs , ) for quadkey , new_assets in new_mosaic . tiles . items (): tile = mercantile . quadkey_to_tile ( quadkey ) assets = self . tile ( * tile ) assets = [ * new_assets , * assets ] self . mosaic_def . tiles [ quadkey ] = assets [: maximum_items_per_tile ] bounds = bbox_union ( new_mosaic . bounds , self . mosaic_def . bounds ) self . mosaic_def . _increase_version () # Increate mosaicjson document version self . mosaic_def . bounds = bounds self . mosaic_def . center = ( ( bounds [ 0 ] + bounds [ 2 ]) / 2 , ( bounds [ 1 ] + bounds [ 3 ]) / 2 , self . mosaic_def . minzoom , ) self . write () return","title":"Custom mosaic update"},{"location":"advanced/readers/","text":"COGReader / STACReader \u00b6 The MosaicJSON backend classes have .tile and .point methods to access the data for a specific mercator tile or point. Because a MosaicJSON can host different assets type, a reader option is available. Set by default to rio_tiler.io.COGReader , or to rio_tiler.io.STACReader for the STACBackend, the reader should know how to read the assets to either create mosaic tile or read points value. from cogeo_mosaic.mosaic import MosaicJSON from cogeo_mosaic.backends import MosaicBackend from rio_tiler.models import ImageData dataset = [ \"1.tif\" , \"2.tif\" ] mosaic_definition = MosaicJSON . from_urls ( dataset ) # Create a mosaic object in memory with MosaicBackend ( None , mosaid_def = mosaic_definition , reader = COGReader ) as mosaic : img , assets_used = mosaic . tile ( 1 , 1 , 1 ) assert isinstance ( img , ImageData ) # By default the STACbackend will store the Item url as assets, but STACReader (default reader) will know how to read them. with MosaicBackend ( \"stac+https://my-stac.api/search\" , { \"collections\" : [ \"satellite\" ]}, 7 , # minzoom 12 , # maxzoom ) as mosaic : img , assets_used = mosaic . tile ( 1 , 1 , 1 , assets = \"red\" ) Let's use a custom accessor to save some specific assets url in the mosaic # accessor to return the url for the `visual` asset (COG) def accessor ( item ): return feature [ \"assets\" ][ \"visual\" ][ \"href\" ] # The accessor will set the mosaic assets as a list of COG url so we can use the COGReader instead of the STACReader with MosaicBackend ( \"stac+https://my-stac.api/search\" , { \"collections\" : [ \"satellite\" ]}, 7 , # minzoom 12 , # maxzoom reader = COGReader , backend_options = { \"accessor\" : accessor }, ) as mosaic : img , assets_used = mosaic . tile ( 1 , 1 , 1 )","title":"Reader"},{"location":"advanced/readers/#cogreader-stacreader","text":"The MosaicJSON backend classes have .tile and .point methods to access the data for a specific mercator tile or point. Because a MosaicJSON can host different assets type, a reader option is available. Set by default to rio_tiler.io.COGReader , or to rio_tiler.io.STACReader for the STACBackend, the reader should know how to read the assets to either create mosaic tile or read points value. from cogeo_mosaic.mosaic import MosaicJSON from cogeo_mosaic.backends import MosaicBackend from rio_tiler.models import ImageData dataset = [ \"1.tif\" , \"2.tif\" ] mosaic_definition = MosaicJSON . from_urls ( dataset ) # Create a mosaic object in memory with MosaicBackend ( None , mosaid_def = mosaic_definition , reader = COGReader ) as mosaic : img , assets_used = mosaic . tile ( 1 , 1 , 1 ) assert isinstance ( img , ImageData ) # By default the STACbackend will store the Item url as assets, but STACReader (default reader) will know how to read them. with MosaicBackend ( \"stac+https://my-stac.api/search\" , { \"collections\" : [ \"satellite\" ]}, 7 , # minzoom 12 , # maxzoom ) as mosaic : img , assets_used = mosaic . tile ( 1 , 1 , 1 , assets = \"red\" ) Let's use a custom accessor to save some specific assets url in the mosaic # accessor to return the url for the `visual` asset (COG) def accessor ( item ): return feature [ \"assets\" ][ \"visual\" ][ \"href\" ] # The accessor will set the mosaic assets as a list of COG url so we can use the COGReader instead of the STACReader with MosaicBackend ( \"stac+https://my-stac.api/search\" , { \"collections\" : [ \"satellite\" ]}, 7 , # minzoom 12 , # maxzoom reader = COGReader , backend_options = { \"accessor\" : accessor }, ) as mosaic : img , assets_used = mosaic . tile ( 1 , 1 , 1 )","title":"COGReader / STACReader"}]}